<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zerononet.github.io</id>
    <title>ZERONONET&apos;s blog</title>
    <updated>2020-11-17T03:40:25.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zerononet.github.io"/>
    <link rel="self" href="https://zerononet.github.io/atom.xml"/>
    <logo>https://zerononet.github.io/images/avatar.png</logo>
    <icon>https://zerononet.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZERONONET&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[知识点备查手册(持续更新中)]]></title>
        <id>https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/</id>
        <link href="https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/">
        </link>
        <updated>2020-11-17T02:23:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="设计模式">设计模式</h2>
<p><a href="https://www.cnblogs.com/pony1223/p/7608955.html">总结参考</a><br>
<br><a href="https://juejin.im/post/6844903695667167240">掘金JAVA设计模式</a><br>
<br>设计模式分类<br>
<img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/401339-20170928225241215-295252070.png" alt="设计模式分类" loading="lazy"></p>
<h3 id="01-七大原则">0.1、七大原则</h3>
<ol>
<li><strong><a href="http://c.biancheng.net/view/1322.html">开闭原则</a></strong><br>
<br>&lt;<strong>定义：</strong>&gt;<br>1.软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。<br>2.开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。<br>&lt;<strong>作用：</strong>&gt;<br>1.对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2.提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>&lt;<strong>实现：</strong>&gt;<br>&lt;a&gt;可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>&lt;b&gt;由于抽象类的灵活性好，适应性广的特点。可以作为软件的架构主心骨。当需要变化而不影响原本功能的情况下，可以根据需要派生一个实现类扩展即可。</li>
<li><strong><a href="http://c.biancheng.net/view/1324.html">里氏替换原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，<strong>是对开闭原则的补充，是对实现抽象化的具体步骤的规范</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.里氏替换原则是实现开闭原则的重要方式之一。<br>2.它克服了继承中重写父类造成的可复用性变差的缺点。<br>3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。<br>4.加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。<br>&lt;<strong>实现：</strong>&gt;<br>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2.子类中可以增加自己特有的方法。<br>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。<br>4.当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>
<li><strong><a href="http://c.biancheng.net/view/1326.html">依赖倒置原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。<strong>其核心思想是：要面向接口编程，不要面向实现编程。</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.依赖倒置原则可以降低类间的耦合性。<br>2.依赖倒置原则可以提高系统的稳定性。<br>3.依赖倒置原则可以减少并行开发引起的风险。<br>4.依赖倒置原则可以提高代码的可读性和可维护性。<br>&lt;<strong>实现：</strong>&gt;<br>1.每个类尽量提供接口或抽象类，或者两者都具备。<br>2.变量的声明类型尽量是接口或者是抽象类。<br>3.任何类都不应该从具体类派生。<br>4.使用继承时尽量遵循里氏替换原则。</li>
<li><strong><a href="http://c.biancheng.net/view/1327.html">单一职责原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。<br>1.降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>2.提高类的可读性。复杂性降低，自然其可读性会提高。<br>3.提高系统的可维护性。可读性提高，那自然更容易维护了。<br>4.变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。<br>&lt;<strong>实现：</strong>&gt;<br>1.单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。<br>2.单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</li>
<li><strong><a href="http://c.biancheng.net/view/1330.html">接口隔离原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br><strong>对比：</strong>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>1.单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>2.单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下5个优点<br>1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3.如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。<br>&lt;<strong>实现：</strong>&gt;<br>1.接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>2.为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>3.了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>4.提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
<li><strong><a href="http://c.biancheng.net/view/1331.html">迪米特法则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。<br>&lt;<strong>作用：</strong>&gt;<br>1.降低了类之间的耦合度，提高了模块的相对独立性。<br>2.由于亲合度降低，从而提高了类的可复用率和系统的扩展性。<br>&lt;<strong>实现：</strong>&gt;<br>强调1.从依赖者的角度来说，只依赖应该依赖的对象。<br>强调2.从被依赖者的角度说，只暴露应该暴露的方法。<br>注意1.在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>注意2.在类的结构设计上，尽量降低类成员的访问权限。<br>注意3.在类的设计上，优先考虑将一个类设置成不变类。<br>注意4.在对其他类的引用上，将引用其他对象的次数降到最低。<br>注意5.不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>注意6.谨慎使用序列化（Serializable）功能。</li>
<li><strong><a href="http://c.biancheng.net/view/1333.html">合成复用原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>1.它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>2.如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。<br>&lt;<strong>作用：</strong>&gt;<br>优点1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>优点2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>优点3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。<br>缺点1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>缺点2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>缺点3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。<br>&lt;<strong>实现：</strong>&gt;<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。<br>
<br><h3>小结：</h3>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</li>
</ol>
<h3 id="1-简单工厂模式">1、<a href="http://c.biancheng.net/view/8385.html">简单工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jiandangongchang.png" alt="工厂方法模式的结构图" loading="lazy"></li>
<li><strong>定义</strong>：<br>    定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。<br>    如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。<br>    在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
<li><strong>优点</strong><br>1.工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。<br>2.客户端无需知道所创建具体产品的类名，只需知道参数即可。<br>3.也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
<li><strong>缺点</strong><br>1.简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。<br>2.使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。<br>3.系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。<br>4.简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
<li><strong><font color="red">CFC总结：</font></strong>增加抽象产品的具体产品需要修改工厂类。</li>
</ul>
<h3 id="2-工厂方法模式">2、<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/gongchang.png" alt="" loading="lazy"></li>
<li><strong>定义</strong>：<br>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</li>
<li><strong>优点</strong><br>1.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。<br>2.灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。<br>3.典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
<li><strong>缺点</strong><br>1.类的个数容易过多，增加复杂度。<br>2.增加了系统的抽象性和理解难度。<br>3.抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/3-1Q11413554DT.png" alt="工厂模式实际应用" loading="lazy"></li>
<li><strong><font color="red">CFC总结：</font></strong>相同产品等级(同类)增加，需要增加对应的工厂类。</li>
</ul>
<h3 id="3-抽象工厂模式">3、<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchang.png" alt="" loading="lazy"></li>
<li><strong>定义</strong>：<br>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。<br><strong>抽象工厂（AbstractFactory）模式的定义</strong>：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dianqigongchangdechanpingdengjiyuchanpingzu.png" alt="电器工厂的产品等级与产品族" loading="lazy"></li>
<li><strong>优点</strong></li>
<li><strong>缺点</strong></li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchangYY.png" alt="抽象工厂实际应用" loading="lazy"></li>
<li><strong><font color="red">CFC总结：</font></strong>工厂只能消费同产品簇，产品簇增加，工厂类增加。</li>
</ul>
<h3 id="4-建造者模式">4、<a href="http://c.biancheng.net/view/1354.html">建造者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozhe.png" alt="建造者模式的结构图" loading="lazy"></li>
<li><strong>定义</strong>：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</li>
<li><strong>优点</strong><br>1.封装性好，构建和表示分离。<br>2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。<br>3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
<li><strong>缺点</strong><br>1.产品的组成部分必须相同，这限制了其使用范围。<br>2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
<li><strong>结合</strong>：建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozheYY.png" alt="抽象工厂实际应用" loading="lazy"></li>
<li><strong><font color="red">CFC总结：</font></strong></li>
</ul>
<h3 id="5-单例模式">5、<a href="http://c.biancheng.net/view/1338.html">单例模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/danli.png" alt="单例模式的结构图" loading="lazy"></li>
<li><strong>定义</strong><br>单例模式有 3 个特点：<br>1.单例类只有一个实例对象；<br>2.该单例对象必须由单例类自行创建；<br>3.单例类对外提供一个访问该单例的全局访问点。</li>
<li><strong>优点</strong><br>1.单例模式可以保证内存里只有一个实例，减少了内存的开销。<br>2.可以避免对资源的多重占用。<br>3.单例模式设置全局访问点，可以优化和共享资源的访问。</li>
<li><strong>缺点</strong><br>1.单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。<br>2.在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。<br>3.单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
<li><strong><font color="red">CFC总结：</font></strong>懒汉模式与饿汉模式中，懒汉虽然节省了初始化时对单例对象的初始化，但是由于每次都需要判断空，并且多线程下可能会有重复创建对象的线程不安全性。导致需要加volatile synchronized关键字，影响了性能。而饿汉模式在初始化时就已经加载了新的对象，而且所有后续的使用都只对这个单例对象做获取动作，不存在线程同步的问题，性能较好。</li>
</ul>
<h3 id="6-原型模式">6、<a href="http://c.biancheng.net/view/1343.html">原型模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxing.png" alt="原型模式的结构图" loading="lazy"></li>
<li><strong>定义</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</li>
<li><strong>优点</strong><br>1.Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。<br>2.可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
<li><strong>缺点</strong><br>1.需要为每一个类都配置一个 clone 方法。<br>2.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。<br>3.当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxingYY.png" alt="原型模式的实际应用" loading="lazy"></li>
</ul>
<h3 id="7-外观模式">7、<a href="http://c.biancheng.net/view/1369.html">外观模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguan.png" alt="外观模式结构图" loading="lazy"></li>
<li><strong>定义</strong>：<font color="blue" >外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</font>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</li>
<li><strong>优点</strong><br>1.降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>2.对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>3.降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
<li><strong>缺点</strong><br>1.不能很好地限制客户使用子系统类，很容易带来未知风险。<br>2.增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguanYY.png" alt="外观模式实际应用" loading="lazy"></li>
</ul>
<h3 id="8-装饰模式">8、<a href="http://c.biancheng.net/view/1366.html">装饰模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshi.png" alt="装饰模式的结构图" loading="lazy"></li>
<li><strong>定义</strong>：装饰（Decorator）指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</li>
<li><strong>优点</strong><br>1.装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用。<br>2.通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。<br>3.装饰器模式完全遵守开闭原则。</li>
<li><strong>缺点</strong>：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshiYY.png" alt="装饰模式实际应用" loading="lazy"></li>
</ul>
<h3 id="9-适配器模式">9、<a href="http://c.biancheng.net/view/1361.html">适配器模式</a></h3>
<ul>
<li><strong>类适配器UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-lei.png" alt="" loading="lazy"></li>
<li><strong>对象适配器UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-duixiang.png" alt="" loading="lazy"></li>
<li><strong>定义</strong><br>1.适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。<br>2.类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</li>
<li><strong>优点</strong><br>1.客户端通过适配器可以透明地调用目标接口。<br>2.复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<br>3.将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。<br>4.在很多业务场景中符合开闭原则。</li>
<li><strong>缺点</strong><br>1.适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。<br>2.增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqiYY.png" alt="发动机适配器实际应用" loading="lazy"></li>
<li><strong><font color="red">CFC总结：</font></strong>类适配器与对象适配器在简单且单一的时候是差不多的，但是当适配器需要处理复杂的适配的时候，涉及多种的情况下，对象适配器可以变种传入对象为传入继承该抽象基类对象的对象(Class&lt;? extends xxx&gt;)来实现多种复杂的适配。</li>
</ul>
<h3 id="10-亨元模式">10、<a href="http://c.biancheng.net/view/1371.html">亨元模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuan.png" alt="亨元模式结构图" loading="lazy"></li>
<li><strong>定义</strong>：享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</li>
<li><strong>优点</strong>1.相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li>
<li><strong>缺点</strong>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>2.读取享元模式的外部状态会使得运行时间稍微变长。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuanYY.png" alt="亨元模式五子棋游戏实际应用" loading="lazy"></li>
</ul>
<h3 id="11-组合模式">11、<a href="http://c.biancheng.net/view/1373.html">组合模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuhe.png" alt="组合模式结构图" loading="lazy"></li>
<li><strong>定义</strong>：</li>
<li><strong>优点</strong><br></li>
<li><strong>缺点</strong><br></li>
</ul>
<h3 id="12-桥接模式">12、<a href="http://c.biancheng.net/view/1364.html">桥接模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojie.png" alt="桥接模式结构图" loading="lazy"></li>
<li><strong>定义</strong>：桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><strong>优点</strong><br>1.抽象与实现分离，扩展能力强。<br>2.符合开闭原则。<br>3.符合合成复用原则。<br>4.其实现细节对客户透明。</li>
<li><strong>缺点</strong><br>1.于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li>
<li><strong>实际应用UML</strong><br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojieYY.png" alt="桥接模式实际应用" loading="lazy"></li>
</ul>
<h3 id="13-代理模式">13、<a href="http://c.biancheng.net/view/1359.html">代理模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/daili.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>定义</strong>：</p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="14-模板方法模式">14、<a href="http://c.biancheng.net/view/1376.html">模板方法模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfa.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<ul>
<li><strong>定义</strong>：</li>
</ul>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="15-迭代器模式">15、<a href="http://c.biancheng.net/view/1395.html">迭代器模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/diedaiqi.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>定义</strong>：</p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="16-策略模式">16、<a href="http://c.biancheng.net/view/1378.html">策略模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celue.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="17-解释器模式">17、<a href="http://c.biancheng.net/view/1402.html">解释器模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jieshiqi.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="18-观察者模式">18、<a href="http://c.biancheng.net/view/1390.html">观察者模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/guanchazhe.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="19-备忘录模式">19、<a href="http://c.biancheng.net/view/1400.html">备忘录模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/beiwanglu.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="20-命令模式">20、<a href="http://c.biancheng.net/view/1380.html">命令模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mingling.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="21-中介者模式">21、<a href="http://c.biancheng.net/view/1393.html">中介者模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhongjiezhe.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="22-责任链模式">22、<a href="http://c.biancheng.net/view/1383.html">责任链模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zerenlian.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>优点</strong></p>
</li>
<li>
<p><strong>缺点</strong></p>
</li>
</ul>
<h3 id="23-访问者模式">23、<a href="http://c.biancheng.net/view/1397.html">访问者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/fangwenzhe.png" alt="" loading="lazy"></li>
<li><strong>优点</strong></li>
<li><strong>缺点</strong></li>
</ul>
<h3 id="24-状态模式">24、<a href="http://c.biancheng.net/view/1388.html">状态模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangtai.png" alt="" loading="lazy"></li>
<li><strong>优点</strong></li>
<li><strong>缺点</strong></li>
</ul>
<h2 id="java并发编程">JAVA并发编程</h2>
<h3 id="1-volatile">1、volatile</h3>
<ul>
<li>强制将变量修改后的值从工作内存写入主内存，保证线程变量的可见性及有序性。但是有序又涉及到了复杂的指令重排、内存屏障等，未做了解。<br></li>
<li>volatile并不能保证原子性，原子性问题得依赖synchronized、ReentrantLock等加锁机制来解决。</li>
<li>另外，多个线程同时修改同一个变量，可能导致线程安全问题，数据混乱问题(修改错乱)，这也是不能保证原子性的原因。</li>
<li><strong>问题一(总线风暴)</strong>：每个处理器通过嗅探在总线上传播的数据来验证自己缓存的数据是否过期。而<strong>嗅探的缺点</strong>是由于Volatile的MESI缓存一直性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会达到总线的峰值。</li>
<li><strong>问题二(禁止指令重排)</strong>：涉及很多计算机底层，告辞</li>
<li><strong>指令重排(一般指令重排分为三种)</strong>：<br>&lt;a&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;<br>&lt;b&gt;指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;<br>&lt;c&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li>
</ul>
<h3 id="2-java8如何优化cas性能">2、JAVA8如何优化CAS性能</h3>
<ul>
<li>全称compare and set——<strong>先比较再设置</strong></li>
<li>在并发操作变量时，cas提供了一系列的Atomic原子类来提供操作。</li>
<li><strong>优化的点</strong>：可以代替synchronized变量的高并发修改赋值，也就是不需要重复的等待锁-&gt;加锁-&gt;修改赋值-&gt;释放锁的类似串行化的步骤。</li>
<li><strong>原子性</strong>：操作完整执行完并且不会被别人打断。</li>
<li><strong>底层原理</strong>：首先获取变量值，询问比较是否发生变化，如果变化则重新获取值，如果未变化则赋值，最后完成这一CAS原子操作。由于加了先比较后赋值的处理机制，可以去掉加锁的机制，所以所有线程可以同步进行这一CAS原子操作。</li>
<li><strong>缺点</strong>：由于获取值的过程中会有大量的获取动作(会有大量的比较失败的情况)，导致高并发的时候线程空循环，自旋，性能效率不是很理想。</li>
<li><strong>针对缺点的优化</strong>：JAVA8中推出了新的类-LongAdder，再采取分段CAS以及自动分段迁移的方式大幅提升多线程高并发的性能问题。</li>
<li><strong>分段CAS机制</strong>：<br>
需要再次梳理分段CAS机制</li>
</ul>
<h3 id="3-各种锁的应用场景">3、各种锁的应用场景</h3>
<ul>
<li><strong>互斥锁</strong>：互斥锁加锁失败后会释放cpu给其他线程。<br>
<br>互斥锁是一种独占锁，在A线程独占锁之后B线程加锁失败的情况下，并且B释放掉cpu后，就会阻塞后续的代码。这种锁是由<strong>操作系统底层内核实现</strong>的，当加锁失败后线程被设置为睡眠，后续由系统来在合适的时机唤醒线程，并继续加锁执行。<br>
<br><strong>开销成本</strong>：有两次的上下文切换的成本。而这上下文切换的时间由于操作系统虚拟内存的原因会比较耗时，在代码执行时间短的情况下上下文切换的时间会比代码执行的时间更久，拖累线程速度。<br>
<br><strong>线程的上下文切换的是什么？</strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
<li><strong>自旋锁</strong>：加锁失败后线程会忙等待，直到拿到锁。<br>
<br>自旋锁是通过cpu提供的<strong>CAS函数(Compare and Swap)</strong>在[用户态]完成加锁和解锁的操作，不会主动产生上下文切换,比互斥锁开销会小。<br>一般加锁分为2个步骤：<br>1.查看锁的状态，如果是空闲的则执行第二步;<br>2.将锁设置为线程持有;<br>CAS函数将这2个步骤合并为一条硬件级指令，形成原子指令，这样就保证了要么执行完，要么完全没执行。<br>
<br><strong>开销成本</strong>：在其他线程等待锁的情况下，会利用cpu周期不断自旋，如果在锁代码执行周期较长的情况下，会较大消耗cpu资源。<br>
<br><h3> CFC小结： </h3>    以上2个锁构成了最基本的锁的方式。简单的可以从需要加锁的代码执行时长来判断使用哪种锁。</li>
<li><strong>读写锁</strong>：分为公平性与非公平性，或读写的优先级锁。</li>
<li><strong>公平锁</strong>即按照队列将读锁与写锁顺序执行。</li>
<li><strong>非公平锁</strong>会造成锁之间的竞争，不管是读锁优先还是写锁优先都会造成另一个锁饥饿甚至饿死的情况。</li>
<li><strong>悲观锁</strong>：以上即悲观。</li>
<li><strong>乐观锁</strong>：其实是没有锁的状态也称无锁编程。主要是在先修改后比较原先资源是否被修改过，如果被修改过则放弃修改重新读取修改。重试的成本高，所以只适用于<strong>冲突少</strong>的场景，类似于git，svn。</li>
<li><strong>Synchronized的实现</strong>：</li>
</ul>
<h2 id="jvm底层">JVM底层</h2>
<h3 id="垃圾回收">垃圾回收</h3>
<p><strong>GC 的几种主要的收集方法</strong>：标记清除、标记整理、复制算法</p>
<ul>
<li><strong>垃圾的识别</strong>：<br>1. 引用计数器(无法解决循环引用问题)——当A实例引用B实例，B实例引用A实例时，对象没有其他引用后依然无法被识别并回收。<br>2.可达性算法：以GC ROOT为根不断寻找下一个节点，任何不在引用链上的都会被标记为垃圾。但是在标记前会执行一次(有且只有一次，如果已执行过则不执行)finalize方法，然后重新判断是否在引用链上，如果仍然不在才能被标记。<br>3.GC ROOT：<br>&lt;a&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>&lt;b&gt;方法区中类静态属性引用的对象。<br>&lt;c&gt;方法区中常量引用的对象。<br>&lt;d&gt;本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
<li><strong>标记清除算法</strong>：根据可达性算法标记出相应的可回收对象，直接回收。</li>
<li><strong>复制算法</strong>：首先要把堆分成2块区域A跟B，将清除后的内存空间A复制到B空间中并紧密排列，清理堆A中所有对象，释放A空间。</li>
<li><strong>标记整理算法</strong>：在标记清除算法的基础上将所有存活的对象都往一个方向移动，并清理掉另外一边所有区域。频繁移动存货对象导致效率低下。</li>
<li><strong>分代收集算法</strong>：整合了以上所有算法，综合了优点，并最大程度避免他们的缺点。根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。<br>
需要再次梳理分代收集算法</li>
</ul>
<h3 id="aqsabstractqueuedsynchronizer抽象队列同步器">AQS(AbstractQueuedSynchronizer)抽象队列同步器</h3>
<p>ReentrantLock可重入锁与ReentrantReadWriteLock可可重入读写锁底层都是基于AQS实现的。</p>
<h3 id="arraylist">ArrayList</h3>
<p><strong>ArrayList与Vector的区别</strong>：<br>
Vector所有方法都是同步的，在不需要多线程保证线程安全的情况下可以使用ArrayList减少不必要的大量同步操作。<br>
<br><strong>ArrayList的扩容机制</strong>：<br>
<br><br><br><br></p>
<h3 id="hashmap底层实现">HashMap底层实现</h3>
<p><strong>java1.8之前</strong>：数组加链表组成的链表散列，通过key的扰动函数处理后得到hash值，通过(n-1)&amp;hash判断当前元素存放位置，如果当前位置存在元素，相当于已经有了这个key，如果key与hash都相同，直接覆盖当前位置的值。如果不相同就通过拉链法解决冲突。<br>
<br><strong>扰动函数</strong>：<br>
<br><strong>存储结构</strong>：数组+链表+红黑树(1.8+)，链表长度大于8时转成链表转成红黑树。<br>
<br><strong>链地址法</strong>：数组加链表的结合。每个数组上都有个链表结构，执行key的hashcode()方法得到hash值，再通过Hash算法的后两步运算(高位运算和取模运算)定位该键值对的存储位置，如果2个key定位到相同位置说明发生hash碰撞，碰撞概率取决与桶(node)的大小与Hash算法。所以为了减少碰撞会有扩容机制。<br>
<br><strong>初始化</strong>：哈希桶数组(node[] table)初始大小为16。负载因子默认为0.75。<br>
<br><strong>扩容机制</strong>：在默认情况下每次put操作都会比较当前容量与存放数量(size)，如果size大于16*0.75=12时，会进行扩容操作。<strong>扩容时会重新计算每个元素在数组中的位置然后再进行存储，十分消耗性能</strong>。<br>
<br><strong>线程不安全</strong>：resize()的时候多线程情况下头插法会使得链路出现环形链表甚至数组下标超出。而1.8后使用的是尾插去优化仍然带来了其他问题，比如尾插时计算相同的存放位置，如果在A线程put完成后，B线程又正好计算在Aput前计算完成存放位置，就会把A线程put的值给覆盖，而不是判断是否碰撞，造成线程不安全。</p>
<h3 id="动态代理">动态代理</h3>
<h2 id="spring框架">Spring框架</h2>
<h3 id="spring-ioc">Spring IOC</h3>
<ul>
<li><strong>IoC - Inversion of Control, 控制反转</strong>：控制反转就是把创建和管理 bean 的过程转移给了第三方。而这个第三方，就是 Spring IoC Container，对于 IoC 来说，最重要的就是容器。</li>
<li><strong>IOC其实是一个编程思想，具体实现是DI 依赖注入</strong></li>
<li><strong>为什么需要使用IOC</strong>：解耦。</li>
<li><strong>使用</strong>：通过xml配置bean属性，然后 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);通过context对象取得xml中配置的bean，并会自动将配置的属性对应值赋上。</li>
<li><strong>对象在容器中是否单例</strong>：是</li>
<li><strong>容器的对象是什么时候创建的</strong>：每次启动容器的时候就已经创建好其中的对象了。</li>
</ul>
<h3 id="spring-aop">Spring AOP</h3>
<h2 id="redis">Redis</h2>
<h3 id="五大数据结构">五大数据结构</h3>
<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
</ul>
<h3 id="缓存过期">缓存过期</h3>
<ul>
<li>过于集中的缓存过期时间会导致短暂卡顿现象——<strong>缓存雪崩</strong>。<br>解决：将失效时间加上随机值，分散过期。</li>
</ul>
<h3 id="持久化">持久化</h3>
<ul>
<li><strong>RDB做镜像全量持久化，AOF做增量持久化</strong>。全量需要时间长，容易丢失大量数据，需要AOF配合。恢复的时候也是一样，先全量恢复，然后增量恢复到重启前状态。<br>突然断电的情况数据丢失取决于AOF日志于sync配置，但是往往每条指令都sync一下到磁盘是不现实的，一般使用定时，一秒一次，最多丢失一秒的数据。</li>
<li><strong>RDB原理</strong>：fork AND cow——fork值redis通过创建子进程进行rdb操作；cow指的是copy on write，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开。</li>
</ul>
<h3 id="同步机制">同步机制</h3>
<ul>
<li><strong>可以主从同步或从从同步</strong>。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</li>
</ul>
<h3 id="集群与高可用">集群与高可用</h3>
<ul>
<li><strong>Redis Sentinal</strong> 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li>
<li><strong>Redis Cluster</strong> 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li>
</ul>
<h3 id="分布式锁">分布式锁</h3>
<ul>
<li>先拿setnx来争抢锁，抢到后使用<strong>expire</strong>来设置过期时间。</li>
<li><strong>存在问题(同存在与Zookeeper、Mysql中)</strong>：当JAVA中执行的GC为STW stop the world的时候，可能会导致锁获得锁的线程A停顿等待GC完成，此时获取到的分布式锁过期，超时释放。其他线程B获取继续获取到锁，开始写数据。而A线程GC完成，继续执行写数据的操作。导致分布式锁不安全(相当于是2个线程同时获取到锁)。</li>
<li><strong>不能执行过长时间的任务</strong>：加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，导致代码无法严格的串行执行。锁被提前释放，提前持有。<br>解决：稍微安全一点的方案是 将锁的 value 值设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自动释放的。但是匹配 value 和删除 key 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 保证多个指令的原子性执行。</li>
</ul>
<h3 id="跳跃表">跳跃表</h3>
<ul>
<li><strong>多层链表</strong>：从最上层的链表(节点少)去查找并比对，一层一层往下定位直到找到位置。<br>优势：可以跳过很多节点，提高查找效率。</li>
</ul>
<h2 id="数据结构与算法">数据结构与算法</h2>
<h3 id="红黑树自平衡二叉查找树">红黑树(自平衡二叉查找树)</h3>
<ul>
<li><strong>二叉查找树（BST）特性</strong>：<br>1.左子树上所有结点的值均小于或等于它的根结点的值。<br>2.右子树上所有结点的值均大于或等于它的根结点的值。<br>3.左、右子树也分别为二叉排序树。</li>
<li><strong>只读操作相同</strong></li>
<li><strong>红黑树性质：</strong><br>1.节点是红色或黑色。<br>2.根是黑色。<br>3.所有叶子都是黑色（叶子是NIL节点）。<br>4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
<li><strong>操作：1.变色；2.左旋转；3.右旋转；</strong></li>
<li><strong>插入</strong></li>
<li><strong>删除</strong></li>
</ul>
]]></content>
    </entry>
</feed>