<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zerononet.github.io</id>
    <title>ZERONONET&apos;s blog</title>
    <updated>2020-11-17T07:13:08.417Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zerononet.github.io"/>
    <link rel="self" href="https://zerononet.github.io/atom.xml"/>
    <logo>https://zerononet.github.io/images/avatar.png</logo>
    <icon>https://zerononet.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZERONONET&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[知识点备查手册(持续更新中)]]></title>
        <id>https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/</id>
        <link href="https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/">
        </link>
        <updated>2020-11-17T02:23:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="设计模式">设计模式</h2>
<p><a href="https://www.cnblogs.com/pony1223/p/7608955.html">总结参考</a><br>
<br><a href="https://juejin.im/post/6844903695667167240">掘金JAVA设计模式</a><br>
<br><center>设计模式分类<br>
<img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/401339-20170928225241215-295252070.png" alt="设计模式分类" loading="lazy"></center></p>
<h3 id="01-七大原则">0.1、七大原则</h3>
<ol>
<li><strong><a href="http://c.biancheng.net/view/1322.html">开闭原则</a></strong><br>
<br>&lt;<strong>定义：</strong>&gt;<br>1.软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。<br>2.开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。<br>&lt;<strong>作用：</strong>&gt;<br>1.对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2.提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>&lt;<strong>实现：</strong>&gt;<br>&lt;a&gt;可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>&lt;b&gt;由于抽象类的灵活性好，适应性广的特点。可以作为软件的架构主心骨。当需要变化而不影响原本功能的情况下，可以根据需要派生一个实现类扩展即可。</li>
<li><strong><a href="http://c.biancheng.net/view/1324.html">里氏替换原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，<strong>是对开闭原则的补充，是对实现抽象化的具体步骤的规范</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.里氏替换原则是实现开闭原则的重要方式之一。<br>2.它克服了继承中重写父类造成的可复用性变差的缺点。<br>3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。<br>4.加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。<br>&lt;<strong>实现：</strong>&gt;<br>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2.子类中可以增加自己特有的方法。<br>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。<br>4.当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li>
<li><strong><a href="http://c.biancheng.net/view/1326.html">依赖倒置原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。<strong>其核心思想是：要面向接口编程，不要面向实现编程。</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.依赖倒置原则可以降低类间的耦合性。<br>2.依赖倒置原则可以提高系统的稳定性。<br>3.依赖倒置原则可以减少并行开发引起的风险。<br>4.依赖倒置原则可以提高代码的可读性和可维护性。<br>&lt;<strong>实现：</strong>&gt;<br>1.每个类尽量提供接口或抽象类，或者两者都具备。<br>2.变量的声明类型尽量是接口或者是抽象类。<br>3.任何类都不应该从具体类派生。<br>4.使用继承时尽量遵循里氏替换原则。</li>
<li><strong><a href="http://c.biancheng.net/view/1327.html">单一职责原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。<br>1.降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>2.提高类的可读性。复杂性降低，自然其可读性会提高。<br>3.提高系统的可维护性。可读性提高，那自然更容易维护了。<br>4.变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。<br>&lt;<strong>实现：</strong>&gt;<br>1.单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。<br>2.单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</li>
<li><strong><a href="http://c.biancheng.net/view/1330.html">接口隔离原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br><strong>对比：</strong>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>1.单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>2.单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下5个优点<br>1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3.如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。<br>&lt;<strong>实现：</strong>&gt;<br>1.接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>2.为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>3.了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>4.提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
<li><strong><a href="http://c.biancheng.net/view/1331.html">迪米特法则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。<br>&lt;<strong>作用：</strong>&gt;<br>1.降低了类之间的耦合度，提高了模块的相对独立性。<br>2.由于亲合度降低，从而提高了类的可复用率和系统的扩展性。<br>&lt;<strong>实现：</strong>&gt;<br>强调1.从依赖者的角度来说，只依赖应该依赖的对象。<br>强调2.从被依赖者的角度说，只暴露应该暴露的方法。<br>注意1.在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>注意2.在类的结构设计上，尽量降低类成员的访问权限。<br>注意3.在类的设计上，优先考虑将一个类设置成不变类。<br>注意4.在对其他类的引用上，将引用其他对象的次数降到最低。<br>注意5.不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>注意6.谨慎使用序列化（Serializable）功能。</li>
<li><strong><a href="http://c.biancheng.net/view/1333.html">合成复用原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>1.它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>2.如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。<br>&lt;<strong>作用：</strong>&gt;<br>优点1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>优点2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>优点3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。<br>缺点1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>缺点2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>缺点3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。<br>&lt;<strong>实现：</strong>&gt;<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。<br>
<br><h3>小结：</h3>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</li>
</ol>
<h3 id="1-简单工厂模式">1、<a href="http://c.biancheng.net/view/8385.html">简单工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jiandangongchang.png" alt="工厂方法模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>    定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。<br>    如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。<br>    在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
<li><strong>优点</strong><br>1.工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。<br>2.客户端无需知道所创建具体产品的类名，只需知道参数即可。<br>3.也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
<li><strong>缺点</strong><br>1.简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。<br>2.使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。<br>3.系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。<br>4.简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
<li><strong>应用场景</strong><br></li>
<li><strong><font color="red">CFC总结：</font></strong>增加抽象产品的具体产品需要修改工厂类。</li>
</ul>
<h3 id="2-工厂方法模式">2、<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/gongchang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</li>
<li><strong>优点</strong><br>1.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。<br>2.灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。<br>3.典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
<li><strong>缺点</strong><br>1.类的个数容易过多，增加复杂度。<br>2.增加了系统的抽象性和理解难度。<br>3.抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/3-1Q11413554DT.png" alt="工厂模式实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>相同产品等级(同类)增加，需要增加对应的工厂类。</li>
</ul>
<h3 id="3-抽象工厂模式">3、<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。<br><strong>抽象工厂（AbstractFactory）模式的定义</strong>：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dianqigongchangdechanpingdengjiyuchanpingzu.png" alt="电器工厂的产品等级与产品族" loading="lazy"></center></li>
<li><strong>优点</strong></li>
<li><strong>缺点</strong></li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchangYY.png" alt="抽象工厂实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>工厂只能消费同产品簇，产品簇增加，工厂类增加。</li>
</ul>
<h3 id="4-建造者模式">4、<a href="http://c.biancheng.net/view/1354.html">建造者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozhe.png" alt="建造者模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</li>
<li><strong>优点</strong><br>1.封装性好，构建和表示分离。<br>2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。<br>3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
<li><strong>缺点</strong><br>1.产品的组成部分必须相同，这限制了其使用范围。<br>2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>结合</strong>：建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozheYY.png" alt="抽象工厂实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong></li>
</ul>
<h3 id="5-单例模式">5、<a href="http://c.biancheng.net/view/1338.html">单例模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/danli.png" alt="单例模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong><br>单例模式有 3 个特点：<br>1.单例类只有一个实例对象；<br>2.该单例对象必须由单例类自行创建；<br>3.单例类对外提供一个访问该单例的全局访问点。</li>
<li><strong>优点</strong><br>1.单例模式可以保证内存里只有一个实例，减少了内存的开销。<br>2.可以避免对资源的多重占用。<br>3.单例模式设置全局访问点，可以优化和共享资源的访问。</li>
<li><strong>缺点</strong><br>1.单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。<br>2.在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。<br>3.单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong><font color="red">CFC总结：</font></strong>懒汉模式与饿汉模式中，懒汉虽然节省了初始化时对单例对象的初始化，但是由于每次都需要判断空，并且多线程下可能会有重复创建对象的线程不安全性。导致需要加volatile synchronized关键字，影响了性能。而饿汉模式在初始化时就已经加载了新的对象，而且所有后续的使用都只对这个单例对象做获取动作，不存在线程同步的问题，性能较好。</li>
</ul>
<h3 id="6-原型模式">6、<a href="http://c.biancheng.net/view/1343.html">原型模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxing.png" alt="原型模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</li>
<li><strong>优点</strong><br>1.Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。<br>2.可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
<li><strong>缺点</strong><br>1.需要为每一个类都配置一个 clone 方法。<br>2.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。<br>3.当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxingYY.png" alt="原型模式的实际应用" loading="lazy"></center></li>
</ul>
<h3 id="7-外观模式">7、<a href="http://c.biancheng.net/view/1369.html">外观模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguan.png" alt="外观模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：<font color="blue" >外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</font>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</li>
<li><strong>优点</strong><br>1.降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>2.对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>3.降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
<li><strong>缺点</strong><br>1.不能很好地限制客户使用子系统类，很容易带来未知风险。<br>2.增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguanYY.png" alt="外观模式实际应用" loading="lazy"></center></li>
</ul>
<h3 id="8-装饰模式">8、<a href="http://c.biancheng.net/view/1366.html">装饰模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshi.png" alt="装饰模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：装饰（Decorator）指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</li>
<li><strong>优点</strong><br>1.装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用。<br>2.通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。<br>3.装饰器模式完全遵守开闭原则。</li>
<li><strong>缺点</strong>：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshiYY.png" alt="装饰模式实际应用" loading="lazy"></center></li>
</ul>
<h3 id="9-适配器模式">9、<a href="http://c.biancheng.net/view/1361.html">适配器模式</a></h3>
<ul>
<li><strong>类适配器UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-lei.png" alt="" loading="lazy"></center></li>
<li><strong>对象适配器UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-duixiang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong><br>1.适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。<br>2.类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</li>
<li><strong>优点</strong><br>1.客户端通过适配器可以透明地调用目标接口。<br>2.复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<br>3.将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。<br>4.在很多业务场景中符合开闭原则。</li>
<li><strong>缺点</strong><br>1.适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。<br>2.增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqiYY.png" alt="发动机适配器实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>类适配器与对象适配器在简单且单一的时候是差不多的，但是当适配器需要处理复杂的适配的时候，涉及多种的情况下，对象适配器可以变种传入对象为传入继承该抽象基类对象的对象(Class&lt;? extends xxx&gt;)来实现多种复杂的适配。</li>
</ul>
<h3 id="10-亨元模式">10、<a href="http://c.biancheng.net/view/1371.html">亨元模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuan.png" alt="亨元模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</li>
<li><strong>优点</strong>1.相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li>
<li><strong>缺点</strong>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>2.读取享元模式的外部状态会使得运行时间稍微变长。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuanYY.png" alt="亨元模式五子棋游戏实际应用" loading="lazy"></center></li>
</ul>
<h3 id="11-组合模式">11、<a href="http://c.biancheng.net/view/1373.html">组合模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><strong>透明式组合模式</strong>中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图所示。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuhe-touming.png" alt="透明式组合模式结构图" loading="lazy"></center><br>
<br><strong>安全式组合模式</strong>中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图所示。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuhe-anquan.png" alt="安全式组合模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：组合（Composite Pattern）模式有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型设计模式。组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheshuxingjiegoutu.png" alt="组合模式树形结构图" loading="lazy"></center><br>
<br>由上图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利</li>
<li><strong>优点</strong><br>1.组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。<br>2.更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。</li>
<li><strong>缺点</strong><br>1.设计较复杂，客户端需要花更多时间理清类之间的层次关系。<br>2.不容易限制容器中的构件。<br>3.不容易用继承的方法来增加构件的新功能。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheYY-tjyj.gif" alt="组合模式实际应用" loading="lazy"></center></li>
<li><strong>复杂实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheYY-fuza.gif" alt="组合模式复杂应用" loading="lazy"></center></li>
</ul>
<h3 id="12-桥接模式">12、<a href="http://c.biancheng.net/view/1364.html">桥接模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojie.png" alt="桥接模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><strong>优点</strong><br>1.抽象与实现分离，扩展能力强。<br>2.符合开闭原则。<br>3.符合合成复用原则。<br>4.其实现细节对客户透明。</li>
<li><strong>缺点</strong><br>1.于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojieYY.png" alt="桥接模式实际应用" loading="lazy"></center></li>
</ul>
<h3 id="13-代理模式">13、<a href="http://c.biancheng.net/view/1359.html">代理模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/daili.gif" alt="" loading="lazy"></center></p>
</li>
<li>
<p><strong>定义</strong>：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</li>
<li>
<p><strong>优点</strong><br>1.代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。<br>2.代理对象可以扩展目标对象的功能。<br>3.代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。</p>
</li>
<li>
<p><strong>缺点</strong><br>1.代理模式会造成系统设计中类的数量增加。<br>2.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。<br>3.增加了系统的复杂度。</p>
</li>
<li>
<p><strong>应用场景</strong>：当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。<br>
<br>1.远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。<br>2.虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。<br>3.安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。<br>4.智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。<br>5.延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</p>
</li>
<li>
<p><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dailiYY.gif" alt="代理模式实际应用" loading="lazy"></center></p>
</li>
<li>
<p><strong>动态代理UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dailiKZdongtai.gif" alt="代理模式实际应用" loading="lazy"></center></p>
</li>
</ul>
<h3 id="14-模板方法模式">14、<a href="http://c.biancheng.net/view/1376.html">模板方法模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfa.gif" alt="模板方法结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：模板方法（Template Method）定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</li>
<li><strong>优点</strong><br>1.它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。<br>2.它在父类中提取了公共的部分代码，便于代码复用。<br>3.部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
<li><strong>缺点</strong><br>1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。<br>2.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。<br>3.由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>
<li><strong>应用场景</strong><br>1.算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。<br>2.当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。<br>3.当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
<li><strong>扩展</strong>：在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图所示<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfahangouzi.png" alt="含钩子方法的模板方法模式的结构图" loading="lazy"></center></li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfaYY.gif" alt="模板方法实际应用" loading="lazy"></center></li>
</ul>
<h3 id="15-迭代器模式">15、<a href="http://c.biancheng.net/view/1395.html">迭代器模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/diedaiqi.gif" alt="迭代器结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：迭代器（Iterator）模式提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式</li>
<li><strong>优点</strong><br>1.访问一个聚合对象的内容而无须暴露它的内部表示。<br>2.遍历任务交由迭代器完成，这简化了聚合类。<br>3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。<br>4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br>5.封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
<li><strong>缺点</strong><br>1.增加了类的个数，这在一定程度上增加了系统的复杂性。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/diedaiqiYY.gif" alt="迭代器模式实际应用" loading="lazy"></center></li>
</ul>
<h3 id="16-策略模式">16、<a href="http://c.biancheng.net/view/1378.html">策略模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celue.gif" alt="策略模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：策略（Strategy）模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</li>
<li><strong>优点</strong><br>1.多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。<br>2.策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。<br>3.策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。<br>4.策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。<br>5.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
<li><strong>缺点</strong><br>1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。<br>2.策略模式造成很多的策略类，增加维护难度。</li>
<li><strong>应用场景</strong>：策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。<br>1.一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。<br>2.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。<br>3.系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。<br>4.系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。<br>5.多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celueYY.gif" alt="" loading="lazy"></center><br>
<br><center>大闸蟹做菜策略的结构图</center><br></li>
<li><strong>扩展</strong>：在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，其结构图如图所示<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celuegongchang.png" alt="策略工厂模式的结构图" loading="lazy"></center><br>
<br><center>策略工厂模式的结构图</center><br></li>
</ul>
<h3 id="17-解释器模式">17、<a href="http://c.biancheng.net/view/1402.html">解释器模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jieshiqi.gif" alt="解释器模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：解释器（Interpreter）模式给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</li>
<li><strong>优点</strong><br>1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。<br>2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
<li><strong>缺点</strong><br>1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。<br>2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。<br>3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
<li><strong>应用场景</strong>：<br>1.当语言的文法较为简单，且执行效率不是关键问题时。<br>2.当问题重复出现，且可以用一种简单的语言来进行表达时。<br>3.当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。<br>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</li>
</ul>
<h3 id="18-观察者模式">18、<a href="http://c.biancheng.net/view/1390.html">观察者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/guancazhe.gif" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：观察者（Observer）模式指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</li>
<li><strong>优点</strong><br>1.降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。<br>2.目标与观察者之间建立了一套触发机制。</li>
<li><strong>缺点</strong><br>1.目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。<br>2.当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
<li><strong>应用场景</strong><br>1.对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。<br>2.当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。<br>3.实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。<br>4.多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/guancazheYY.gif" alt="" loading="lazy"></center><br>
<br><center>人民币汇率分析程序的结构图</center></li>
</ul>
<h3 id="19-备忘录模式">19、<a href="http://c.biancheng.net/view/1400.html">备忘录模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/beiwanglu.gif" alt="备忘录模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：备忘录（Memento）模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</li>
<li><strong>优点</strong><br>1.提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。<br>2.实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。<br>3.简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
<li><strong>缺点</strong><br>1.资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
<li><strong>应用场景</strong><br>1.需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。<br>2.需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/beiwangluYY.png" alt="" loading="lazy"></center><br>
<br><center>相亲游戏的结构图</center></li>
</ul>
<h3 id="20-命令模式">20、<a href="http://c.biancheng.net/view/1380.html">命令模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mingling.gif" alt="命令模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：命令（Command）模式将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</li>
<li><strong>优点</strong><br>1.通过引入中间件（抽象接口）降低系统的耦合度。<br>2.扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。<br>3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。<br>4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。<br>5.可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li>
<li><strong>缺点</strong><br>1.可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。<br>2.命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
<li><strong>应用场景</strong><br>1.请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。<br>2.系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。<br>3.当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。<br>4.当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/minglingYY.gif" alt="" loading="lazy"></center><br>
<br><center>客户在餐馆吃早餐的结构图</center></li>
</ul>
<h3 id="21-中介者模式">21、<a href="http://c.biancheng.net/view/1393.html">中介者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhongjiezhe.gif" alt="中介者模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：中介者（Mediator）模式定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</li>
<li><strong>优点</strong><br>1.降低了对象之间的耦合性，使得对象易于独立地被复用。<br>2.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
<li><strong>缺点</strong><br>1.当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
<li><strong>应用场景</strong><br>1.当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。<br>2.当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhongjiezheYY.gif" alt="中介者模式实际应用UML" loading="lazy"></center><br>
<br><center>韶关房地产交流平台的结构图</center></li>
</ul>
<h3 id="22-责任链模式">22、<a href="http://c.biancheng.net/view/1383.html">责任链模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zerenlian.gif" alt="责任链模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：责任链（Chain of Responsibility）模式为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</li>
<li><strong>优点</strong><br>1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
<li><strong>缺点</strong><br>1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<br>2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。<br>3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
<li><strong>应用场景</strong><br>1.多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。<br>2.可动态指定一组对象处理请求，或添加新的处理者。<br>3.需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zerenlianYY.gif" alt="责任链模式实际应用" loading="lazy"></center><br>
<br><center>请假条审批模块的结构图</center></li>
</ul>
<h3 id="23-访问者模式">23、<a href="http://c.biancheng.net/view/1397.html">访问者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/fangwenzhe.gif" alt="访问者模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：访问者（Visitor）模式将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>
<li><strong>优点</strong><br>1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。<br>2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。<br>3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。<br>4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
<li><strong>缺点</strong><br>1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。<br>2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。<br>3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
<li><strong>应用场景</strong><br>1.对象结构相对稳定，但其操作算法经常变化的程序。<br>2.对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。<br>3.对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/fangwenzheYY.png" alt="访问者模式实际应用UML" loading="lazy"></center><br>
<br><center>艺术公司与造币公司的结构图</center></li>
</ul>
<h3 id="24-状态模式">24、<a href="http://c.biancheng.net/view/1388.html">状态模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangtai.gif" alt="状态模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：状态（State）模式对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</li>
<li><strong>优点</strong><br>1.结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。<br>2.将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。<br>3.状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
<li><strong>缺点</strong><br>1.状态模式的使用必然会增加系统的类与对象的个数。<br>2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。<br>3.状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li>
<li><strong>应用场景</strong><br>1.当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。<br>2.一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangtaiYY.png" alt="状态模式实际应用UML" loading="lazy"></center><br>
<br><center>学生成绩的状态转换程序的结构图</center></li>
</ul>
<h2 id="java并发编程">JAVA并发编程</h2>
<h3 id="1-volatile">1、volatile</h3>
<ul>
<li>强制将变量修改后的值从工作内存写入主内存，保证线程变量的可见性及有序性。但是有序又涉及到了复杂的指令重排、内存屏障等，未做了解。<br></li>
<li>volatile并不能保证原子性，原子性问题得依赖synchronized、ReentrantLock等加锁机制来解决。</li>
<li>另外，多个线程同时修改同一个变量，可能导致线程安全问题，数据混乱问题(修改错乱)，这也是不能保证原子性的原因。</li>
<li><strong>问题一(总线风暴)</strong>：每个处理器通过嗅探在总线上传播的数据来验证自己缓存的数据是否过期。而<strong>嗅探的缺点</strong>是由于Volatile的MESI缓存一直性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会达到总线的峰值。</li>
<li><strong>问题二(禁止指令重排)</strong>：涉及很多计算机底层，告辞</li>
<li><strong>指令重排(一般指令重排分为三种)</strong>：<br>&lt;a&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;<br>&lt;b&gt;指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;<br>&lt;c&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li>
</ul>
<h3 id="2-java8如何优化cas性能">2、JAVA8如何优化CAS性能</h3>
<ul>
<li>全称compare and set——<strong>先比较再设置</strong></li>
<li>在并发操作变量时，cas提供了一系列的Atomic原子类来提供操作。</li>
<li><strong>优化的点</strong>：可以代替synchronized变量的高并发修改赋值，也就是不需要重复的等待锁-&gt;加锁-&gt;修改赋值-&gt;释放锁的类似串行化的步骤。</li>
<li><strong>原子性</strong>：操作完整执行完并且不会被别人打断。</li>
<li><strong>底层原理</strong>：首先获取变量值，询问比较是否发生变化，如果变化则重新获取值，如果未变化则赋值，最后完成这一CAS原子操作。由于加了先比较后赋值的处理机制，可以去掉加锁的机制，所以所有线程可以同步进行这一CAS原子操作。</li>
<li><strong>缺点</strong>：由于获取值的过程中会有大量的获取动作(会有大量的比较失败的情况)，导致高并发的时候线程空循环，自旋，性能效率不是很理想。</li>
<li><strong>针对缺点的优化</strong>：JAVA8中推出了新的类-LongAdder，再采取分段CAS以及自动分段迁移的方式大幅提升多线程高并发的性能问题。</li>
<li><strong>分段CAS机制</strong>：<br>
需要再次梳理分段CAS机制</li>
</ul>
<h3 id="3-各种锁的应用场景">3、各种锁的应用场景</h3>
<ul>
<li><strong>互斥锁</strong>：互斥锁加锁失败后会释放cpu给其他线程。<br>
<br>互斥锁是一种独占锁，在A线程独占锁之后B线程加锁失败的情况下，并且B释放掉cpu后，就会阻塞后续的代码。这种锁是由<strong>操作系统底层内核实现</strong>的，当加锁失败后线程被设置为睡眠，后续由系统来在合适的时机唤醒线程，并继续加锁执行。<br>
<br><strong>开销成本</strong>：有两次的上下文切换的成本。而这上下文切换的时间由于操作系统虚拟内存的原因会比较耗时，在代码执行时间短的情况下上下文切换的时间会比代码执行的时间更久，拖累线程速度。<br>
<br><strong>线程的上下文切换的是什么？</strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
<li><strong>自旋锁</strong>：加锁失败后线程会忙等待，直到拿到锁。<br>
<br>自旋锁是通过cpu提供的<strong>CAS函数(Compare and Swap)</strong>在[用户态]完成加锁和解锁的操作，不会主动产生上下文切换,比互斥锁开销会小。<br>一般加锁分为2个步骤：<br>1.查看锁的状态，如果是空闲的则执行第二步;<br>2.将锁设置为线程持有;<br>CAS函数将这2个步骤合并为一条硬件级指令，形成原子指令，这样就保证了要么执行完，要么完全没执行。<br>
<br><strong>开销成本</strong>：在其他线程等待锁的情况下，会利用cpu周期不断自旋，如果在锁代码执行周期较长的情况下，会较大消耗cpu资源。<br>
<br><h3> CFC小结： </h3>    以上2个锁构成了最基本的锁的方式。简单的可以从需要加锁的代码执行时长来判断使用哪种锁。</li>
<li><strong>读写锁</strong>：分为公平性与非公平性，或读写的优先级锁。</li>
<li><strong>公平锁</strong>即按照队列将读锁与写锁顺序执行。</li>
<li><strong>非公平锁</strong>会造成锁之间的竞争，不管是读锁优先还是写锁优先都会造成另一个锁饥饿甚至饿死的情况。</li>
<li><strong>悲观锁</strong>：以上即悲观。</li>
<li><strong>乐观锁</strong>：其实是没有锁的状态也称无锁编程。主要是在先修改后比较原先资源是否被修改过，如果被修改过则放弃修改重新读取修改。重试的成本高，所以只适用于<strong>冲突少</strong>的场景，类似于git，svn。</li>
<li><strong>Synchronized的实现</strong>：</li>
</ul>
<h2 id="jvm底层">JVM底层</h2>
<h3 id="垃圾回收">垃圾回收</h3>
<p><strong>GC 的几种主要的收集方法</strong>：标记清除、标记整理、复制算法</p>
<ul>
<li><strong>垃圾的识别</strong>：<br>1. 引用计数器(无法解决循环引用问题)——当A实例引用B实例，B实例引用A实例时，对象没有其他引用后依然无法被识别并回收。<br>2.可达性算法：以GC ROOT为根不断寻找下一个节点，任何不在引用链上的都会被标记为垃圾。但是在标记前会执行一次(有且只有一次，如果已执行过则不执行)finalize方法，然后重新判断是否在引用链上，如果仍然不在才能被标记。<br>3.GC ROOT：<br>&lt;a&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>&lt;b&gt;方法区中类静态属性引用的对象。<br>&lt;c&gt;方法区中常量引用的对象。<br>&lt;d&gt;本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
<li><strong>标记清除算法</strong>：根据可达性算法标记出相应的可回收对象，直接回收。</li>
<li><strong>复制算法</strong>：首先要把堆分成2块区域A跟B，将清除后的内存空间A复制到B空间中并紧密排列，清理堆A中所有对象，释放A空间。</li>
<li><strong>标记整理算法</strong>：在标记清除算法的基础上将所有存活的对象都往一个方向移动，并清理掉另外一边所有区域。频繁移动存货对象导致效率低下。</li>
<li><strong>分代收集算法</strong>：整合了以上所有算法，综合了优点，并最大程度避免他们的缺点。根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。<br>
需要再次梳理分代收集算法</li>
</ul>
<h3 id="aqsabstractqueuedsynchronizer抽象队列同步器">AQS(AbstractQueuedSynchronizer)抽象队列同步器</h3>
<p>ReentrantLock可重入锁与ReentrantReadWriteLock可可重入读写锁底层都是基于AQS实现的。</p>
<h3 id="arraylist">ArrayList</h3>
<p><strong>ArrayList与Vector的区别</strong>：<br>
Vector所有方法都是同步的，在不需要多线程保证线程安全的情况下可以使用ArrayList减少不必要的大量同步操作。<br>
<br><strong>ArrayList的扩容机制</strong>：<br>
<br><br><br><br></p>
<h3 id="hashmap底层实现">HashMap底层实现</h3>
<p><strong>java1.8之前</strong>：数组加链表组成的链表散列，通过key的扰动函数处理后得到hash值，通过(n-1)&amp;hash判断当前元素存放位置，如果当前位置存在元素，相当于已经有了这个key，如果key与hash都相同，直接覆盖当前位置的值。如果不相同就通过拉链法解决冲突。<br>
<br><strong>扰动函数</strong>：<br>
<br><strong>存储结构</strong>：数组+链表+红黑树(1.8+)，链表长度大于8时转成链表转成红黑树。<br>
<br><strong>链地址法</strong>：数组加链表的结合。每个数组上都有个链表结构，执行key的hashcode()方法得到hash值，再通过Hash算法的后两步运算(高位运算和取模运算)定位该键值对的存储位置，如果2个key定位到相同位置说明发生hash碰撞，碰撞概率取决与桶(node)的大小与Hash算法。所以为了减少碰撞会有扩容机制。<br>
<br><strong>初始化</strong>：哈希桶数组(node[] table)初始大小为16。负载因子默认为0.75。<br>
<br><strong>扩容机制</strong>：在默认情况下每次put操作都会比较当前容量与存放数量(size)，如果size大于16*0.75=12时，会进行扩容操作。<strong>扩容时会重新计算每个元素在数组中的位置然后再进行存储，十分消耗性能</strong>。<br>
<br><strong>线程不安全</strong>：resize()的时候多线程情况下头插法会使得链路出现环形链表甚至数组下标超出。而1.8后使用的是尾插去优化仍然带来了其他问题，比如尾插时计算相同的存放位置，如果在A线程put完成后，B线程又正好计算在Aput前计算完成存放位置，就会把A线程put的值给覆盖，而不是判断是否碰撞，造成线程不安全。</p>
<h3 id="动态代理">动态代理</h3>
<h2 id="spring框架">Spring框架</h2>
<h3 id="spring-ioc">Spring IOC</h3>
<ul>
<li><strong>IoC - Inversion of Control, 控制反转</strong>：控制反转就是把创建和管理 bean 的过程转移给了第三方。而这个第三方，就是 Spring IoC Container，对于 IoC 来说，最重要的就是容器。</li>
<li><strong>IOC其实是一个编程思想，具体实现是DI 依赖注入</strong></li>
<li><strong>为什么需要使用IOC</strong>：解耦。</li>
<li><strong>使用</strong>：通过xml配置bean属性，然后 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);通过context对象取得xml中配置的bean，并会自动将配置的属性对应值赋上。</li>
<li><strong>对象在容器中是否单例</strong>：是</li>
<li><strong>容器的对象是什么时候创建的</strong>：每次启动容器的时候就已经创建好其中的对象了。</li>
</ul>
<h3 id="spring-aop">Spring AOP</h3>
<h2 id="redis">Redis</h2>
<h3 id="五大数据结构">五大数据结构</h3>
<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
</ul>
<h3 id="缓存过期">缓存过期</h3>
<ul>
<li>过于集中的缓存过期时间会导致短暂卡顿现象——<strong>缓存雪崩</strong>。<br>解决：将失效时间加上随机值，分散过期。</li>
</ul>
<h3 id="持久化">持久化</h3>
<ul>
<li><strong>RDB做镜像全量持久化，AOF做增量持久化</strong>。全量需要时间长，容易丢失大量数据，需要AOF配合。恢复的时候也是一样，先全量恢复，然后增量恢复到重启前状态。<br>突然断电的情况数据丢失取决于AOF日志于sync配置，但是往往每条指令都sync一下到磁盘是不现实的，一般使用定时，一秒一次，最多丢失一秒的数据。</li>
<li><strong>RDB原理</strong>：fork AND cow——fork值redis通过创建子进程进行rdb操作；cow指的是copy on write，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开。</li>
</ul>
<h3 id="同步机制">同步机制</h3>
<ul>
<li><strong>可以主从同步或从从同步</strong>。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</li>
</ul>
<h3 id="集群与高可用">集群与高可用</h3>
<ul>
<li><strong>Redis Sentinal</strong> 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li>
<li><strong>Redis Cluster</strong> 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li>
</ul>
<h3 id="分布式锁">分布式锁</h3>
<ul>
<li>先拿setnx来争抢锁，抢到后使用<strong>expire</strong>来设置过期时间。</li>
<li><strong>存在问题(同存在与Zookeeper、Mysql中)</strong>：当JAVA中执行的GC为STW stop the world的时候，可能会导致锁获得锁的线程A停顿等待GC完成，此时获取到的分布式锁过期，超时释放。其他线程B获取继续获取到锁，开始写数据。而A线程GC完成，继续执行写数据的操作。导致分布式锁不安全(相当于是2个线程同时获取到锁)。</li>
<li><strong>不能执行过长时间的任务</strong>：加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，导致代码无法严格的串行执行。锁被提前释放，提前持有。<br>解决：稍微安全一点的方案是 将锁的 value 值设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自动释放的。但是匹配 value 和删除 key 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 保证多个指令的原子性执行。</li>
</ul>
<h3 id="跳跃表">跳跃表</h3>
<ul>
<li><strong>多层链表</strong>：从最上层的链表(节点少)去查找并比对，一层一层往下定位直到找到位置。<br>优势：可以跳过很多节点，提高查找效率。</li>
</ul>
<h2 id="数据结构与算法">数据结构与算法</h2>
<h3 id="红黑树自平衡二叉查找树">红黑树(自平衡二叉查找树)</h3>
<ul>
<li><strong>二叉查找树（BST）特性</strong>：<br>1.左子树上所有结点的值均小于或等于它的根结点的值。<br>2.右子树上所有结点的值均大于或等于它的根结点的值。<br>3.左、右子树也分别为二叉排序树。</li>
<li><strong>只读操作相同</strong></li>
<li><strong>红黑树性质：</strong><br>1.节点是红色或黑色。<br>2.根是黑色。<br>3.所有叶子都是黑色（叶子是NIL节点）。<br>4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
<li><strong>操作：1.变色；2.左旋转；3.右旋转；</strong></li>
<li><strong>插入</strong></li>
<li><strong>删除</strong></li>
</ul>
<!--
# <center>升级之路</center> #
## 以实际应用结合讲设计模式 ##
## 1、数据库的锁 ##
#### 行锁（共享锁和排他锁），表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等 ####
## 2、数据结构 ##
#### 红黑树，B树，B+树，二叉树，HashMap ####
## 3、Redis ##
#### 分布式的哨兵到3.0之后的去中心化集群（奇数节点）、高并发、单线程、在线扩容、持久化方式(断电保护) ####
## 4、HashMap ##
#### 单向链表的特性导致会有Entry链、PUT&GET原理，初始容量(rehash扩容问题)，线程不安全(resize死循环)，与HashTable的区别 ####
## 5、线程池 ##
#### 四种线程池，JDK拒绝策略 ####
## 6、JVM ##
#### Object的内存布局，方法区卸载Class的条件，可以作为GC ROOT的对象包括，JVM运行内存模型，Netty的ByteBuffer的引用计数器机制，对象是否存活的判断，JAVA对象的初始化，类加载的双亲委派模型，动态代理模式(cglib,jdk动态代理)####
## 7、Zookeeper ##
#### 常见的应用场景，分布式数据的一致性算法，ZK的启动及Leader选举，数据同步，ZK集群最少需要2N+1，Zookeeper与Eureka的区别 ####
## 8、消息队列 ##
#### 消费者宕机保证消息不丢失，集群宕机保证消息不丢失 ####
## 9、Spring源码 ##
#### springmvc如何解决循环依赖的问题，spring事务的传播行为和隔离级别，Spring事务的五种隔离级别，SpringAOP ####
## 10、设计模式 ##
#### 单例模式(7种)，策略模式 ####
## 11、JDK源码 ##
#### ThreadLocal的实现原理，AQS实现公平锁和非公平锁，RPC的序列方式 ####
## 12、服务熔断与降级概念 ##
#### 服务熔断，服务降级 ####
## 13、索引 ##
#### 正排索引，倒排索引 ####

-->]]></content>
    </entry>
</feed>