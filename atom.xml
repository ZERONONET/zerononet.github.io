<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zerononet.github.io</id>
    <title>ZERONONET&apos;s blog</title>
    <updated>2020-11-27T04:42:46.367Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zerononet.github.io"/>
    <link rel="self" href="https://zerononet.github.io/atom.xml"/>
    <logo>https://zerononet.github.io/images/avatar.png</logo>
    <icon>https://zerononet.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZERONONET&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot的配置与使用]]></title>
        <id>https://zerononet.github.io/post/springboot-de-pei-zhi-yu-shi-yong/</id>
        <link href="https://zerononet.github.io/post/springboot-de-pei-zhi-yu-shi-yong/">
        </link>
        <updated>2020-11-27T03:54:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="center-目录"><center> 目录</h1>
<center><a href="#开发环境搭建和项目启动">Spring Boot开发环境搭建和项目启动</a></center>
<center><a href="#返回Json数据及数据封装">Spring Boot返回Json数据及数据封装</a></center>
<center> <a href="#使用slf4j进行日志记录">Spring Boot使用slf4j进行日志记录</a></center>
<center> <a href="#项目属性配置">Spring Boot中的项目属性配置</a></center>
<center> <a href="#MVC支持">Spring Boot中的MVC支持</a></center>
<center><a href="#集成Swagger2展现在线接口文档">Spring Boot集成Swagger2展现在线接口文档</a></center>
<center> <a href="#集成Thymeleaf模板引擎">Spring Boot集成Thymeleaf模板引擎</a></center>
<center><a href="#全局异常处理">Spring Boot中的全局异常处理</a></center>
<center> <a href="#切面AOP处理">Spring Boot中的切面AOP处理</a></center>
<center><a href="#集成MyBatis">Spring Boot中集成MyBatis</a></center>
<center><a href="#事务配置管理">Spring Boot事务配置管理</a></center>
<center> <a href="#使用监听器">Spring Boot中使用监听器</a></center>
<center> <a href="#拦截器">Spring Boot中使用拦截器</a></center>
<center> <a href="#集成Redis">Spring Boot中集成Redis</a></center>
<center><a href="#集成ActiveMQ">Spring Boot中集成ActiveMQ</a></center>
<center> <a href="#集成Shiro">Spring Boot中集成Shiro</a></center>
<center> <a href="#集成Lucence">Spring Boot中集成Lucence</a></center>
<center> <a href="#搭建实际项目开发中的架构">Spring Boot搭建实际项目开发中的架构</a></center>
<p><a name="开发环境搭建和项目启动"></a></p>
<h1 id="spring-boot开发环境搭建和项目启动">Spring Boot开发环境搭建和项目启动</h1>
<p>上一节对 SpringBoot 的特性做了一个介绍，本节主要对 <strong>jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析</strong>。</p>
<h2 id="1-jdk-的配置">1. jdk 的配置</h2>
<p>本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开<code>File-&gt;Project Structure</code>，如下图所：</p>
<figure data-type="image" tabindex="1"><img src="https://images.gitbook.cn/9befde80-8659-11e8-9b0d-95de449dc107" alt="IDEA中配置jdk" loading="lazy"></figure>
<ol>
<li>选择 SDKs</li>
<li>在 JDK home path 中选择本地 jdk 的安装目录</li>
<li>在 Name 中为 jdk 自定义名字</li>
</ol>
<p>通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加：</p>
<ul>
<li><code>window-&gt;preference-&gt;java-&gt;Instralled JRES</code>来添加本地 jdk。</li>
<li><code>window--&gt;preference--&gt;java--&gt;Compiler</code>选择 jre，和 jdk 保持一致。</li>
</ul>
<h2 id="2-spring-boot-工程的构建">2. Spring Boot 工程的构建</h2>
<h3 id="21-idea-快速构建">2.1 IDEA 快速构建</h3>
<p>IDEA 中可以通过<code>File-&gt;New-&gt;Project</code>来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。</p>
<ul>
<li>Group：填企业域名，本课程使用com.itcodai</li>
<li>Artifact：填项目名称，本课程中每一课的工程名以<code>course+课号</code>命令，这里使用 course01</li>
<li>Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。</li>
</ul>
<h3 id="22-官方构建">2.2 官方构建</h3>
<p>第二种方式可以通过官方构建，步骤如下：</p>
<ul>
<li>访问 http://start.spring.io/。</li>
<li>在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。</li>
<li><img src="https://images.gitbook.cn/014a1ba0-865b-11e8-956e-f528114b28bd" alt="创建Spring Boot工程" loading="lazy"></li>
<li>解压后，使用 IDEA 导入该 maven 工程：<code>File-&gt;New-&gt;Model from Existing Source</code>，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过<code>Import-&gt;Existing Maven Projects-&gt;Next</code>，然后选择解压后的项目文件夹即可。</li>
</ul>
<h3 id="23-maven配置">2.3 maven配置</h3>
<p>创建了 Spring Boot 项目之后，需要进行 maven 配置。打开<code>File-&gt;settings</code>，搜索 maven，配置一下本地的 maven 信息。如下：</p>
<figure data-type="image" tabindex="3"><img src="https://images.gitbook.cn/2ff7b930-865b-11e8-8675-5537a701ae7d" alt="maven配置" loading="lazy"></figure>
<p>在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。</p>
<pre><code class="language-xml">&lt;mirror&gt;
	&lt;id&gt;nexus-aliyun&lt;/id&gt;
	&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
	&lt;name&gt;Nexus aliyun&lt;/name&gt;
	&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre>
<p>如果是使用 eclipse 的朋友，可以通过<code>window--&gt;preference--&gt;Maven--&gt;User Settings</code>来配置，配置方式和上面一致。</p>
<h3 id="24-编码配置">2.4 编码配置</h3>
<p>同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。</p>
<p>IDEA 中，仍然是打开<code>File-&gt;settings</code>，搜索 encoding，配置一下本地的编码信息。如下：</p>
<figure data-type="image" tabindex="4"><img src="https://images.gitbook.cn/57564e60-865b-11e8-8a91-d70bc2d847c5" alt="编码配置" loading="lazy"></figure>
<p>如果是使用 eclipse 的朋友，有两个地方需要设置一下编码：</p>
<ul>
<li>window--&gt; perferences--&gt;General--&gt;Workspace，将Text file encoding改成utf-8</li>
<li>window--&gt;perferences--&gt;General--&gt;content types，选中Text，将Default encoding填入utf-8</li>
</ul>
<p>OK，编码设置完成即可启动项目工程了。</p>
<h2 id="3-spring-boot-项目工程结构">3. Spring Boot 项目工程结构</h2>
<p>Spring Boot 项目总共有三个模块，如下图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://images.gitbook.cn/8b32fa80-865b-11e8-9d13-03ea4b4d8504" alt="Spring Boot项目工程结构" loading="lazy"></figure>
<ul>
<li>src/main/java路径：主要编写业务程序</li>
<li>src/main/resources路径：存放静态文件和配置文件</li>
<li>src/test/java路径：主要编写测试程序</li>
</ul>
<p>默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个<code>@SpringBootApplication</code>注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。</p>
<p>到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下：</p>
<pre><code>package com.itcodai.course01.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/start&quot;)
public class StartController {

    @RequestMapping(&quot;/springboot&quot;)
    public String startSpringBoot() {
        return &quot;Welcome to the world of Spring Boot!&quot;;
    }
}
</code></pre>
<p>重新运行 main 方法启动项目，在浏览器中输入 <code>localhost:8080/start/springboot</code>，如果看到 <code>“Welcome to the world of Spring Boot!”</code>，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 <code>server.port</code> 来人为指定端口，如8001端口：</p>
<pre><code class="language-xml">server:
  port: 8001
</code></pre>
<h2 id="4-总结">4. 总结</h2>
<p>本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。<br>
课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="返回Json数据及数据封装"></a></p>
<h1 id="spring-boot返回json数据及数据封装">Spring Boot返回Json数据及数据封装</h1>
<p>在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用<code>@RestController</code>注解即可返回 Json 格式的数据，<code>@RestController</code>也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    String value() default &quot;&quot;;
}
</code></pre>
<p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 <code>@RestController</code> 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 <code>spring-boot-starter-web</code> 依赖，可以看到一个 <code>spring-boot-starter-json</code> 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;
    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>Spring Boot 中对依赖都做了很好的封装，可以看到很多 <code>spring-boot-starter-xxx</code> 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 <code>spring-boot-starter-json</code> 依赖，可以看到：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.6&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;
    &lt;version&gt;2.9.6&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.9.6&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;
    &lt;version&gt;2.9.6&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。</p>
<h2 id="1-spring-boot-默认对json的处理">1. Spring Boot 默认对Json的处理</h2>
<p>在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。</p>
<h3 id="11-创建-user-实体类">1.1 创建 User 实体类</h3>
<p>为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。</p>
<pre><code class="language-java">public class User {
    private Long id;
    private String username;
    private String password;
	/* 省略get、set和带参构造方法 */
}
</code></pre>
<h3 id="12-创建controller类">1.2 创建Controller类</h3>
<p>然后我们创建一个 Controller，分别返回 <code>User</code>对象、<code>List&lt;User&gt;</code> 和 <code>Map&lt;String, Object&gt;</code>。</p>
<pre><code class="language-java">import com.itcodai.course02.entity.User;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/json&quot;)
public class JsonController {

    @RequestMapping(&quot;/user&quot;)
    public User getUser() {
        return new User(1, &quot;倪升武&quot;, &quot;123456&quot;);
    }

    @RequestMapping(&quot;/list&quot;)
    public List&lt;User&gt; getUserList() {
        List&lt;User&gt; userList = new ArrayList&lt;&gt;();
        User user1 = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);
        User user2 = new User(2, &quot;达人课&quot;, &quot;123456&quot;);
        userList.add(user1);
        userList.add(user2);
        return userList;
    }

    @RequestMapping(&quot;/map&quot;)
    public Map&lt;String, Object&gt; getMap() {
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);
        User user = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);
        map.put(&quot;作者信息&quot;, user);
        map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);
        map.put(&quot;CSDN地址&quot;, &quot;http://blog.csdn.net/eson_15&quot;);
        map.put(&quot;粉丝数量&quot;, 4153);
        return map;
    }
}
</code></pre>
<h3 id="13-测试不同数据类型返回的json">1.3 测试不同数据类型返回的json</h3>
<p>OK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。</p>
<p>在浏览器中输入：<code>localhost:8080/json/user</code> 返回 json 如下：</p>
<pre><code class="language-json">{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;}
</code></pre>
<p>在浏览器中输入：<code>localhost:8080/json/list</code> 返回 json 如下：</p>
<pre><code class="language-json">[{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;},{&quot;id&quot;:2,&quot;username&quot;:&quot;达人课&quot;,&quot;password&quot;:&quot;123456&quot;}]
</code></pre>
<p>在浏览器中输入：<code>localhost:8080/json/map</code> 返回 json 如下：</p>
<pre><code class="language-json">{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;123456&quot;},&quot;CSDN地址&quot;:&quot;http://blog.csdn.net/eson_15&quot;,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;}
</code></pre>
<p>可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。</p>
<h3 id="14-jackson-中对null的处理">1.4 jackson 中对null的处理</h3>
<p>在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 &quot;&quot; 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类：</p>
<pre><code class="language-java">import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializerProvider;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;

import java.io.IOException;

@Configuration
public class JacksonConfig {
    @Bean
    @Primary
    @ConditionalOnMissingBean(ObjectMapper.class)
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper objectMapper = builder.createXmlMapper(false).build();
        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {
            @Override
            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
                jsonGenerator.writeString(&quot;&quot;);
            }
        });
        return objectMapper;
    }
}
</code></pre>
<p>然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下：</p>
<pre><code class="language-java">@RequestMapping(&quot;/map&quot;)
public Map&lt;String, Object&gt; getMap() {
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);
    User user = new User(1, &quot;倪升武&quot;, null);
    map.put(&quot;作者信息&quot;, user);
    map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);
    map.put(&quot;CSDN地址&quot;, null);
    map.put(&quot;粉丝数量&quot;, 4153);
    return map;
}
</code></pre>
<p>重启项目，再次输入：<code>localhost:8080/json/map</code>，可以看到 jackson 已经将所有 null 字段转成了空字符串了。</p>
<pre><code class="language-json">{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;username&quot;:&quot;倪升武&quot;,&quot;password&quot;:&quot;&quot;},&quot;CSDN地址&quot;:&quot;&quot;,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;}
</code></pre>
<h2 id="2-使用阿里巴巴fastjson的设置">2. 使用阿里巴巴FastJson的设置</h2>
<h3 id="21-jackson-和-fastjson-的对比">2.1 jackson 和 fastJson 的对比</h3>
<p>有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">fastJson</th>
<th style="text-align:center">jackson</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上手难易程度</td>
<td style="text-align:center">容易</td>
<td style="text-align:center">中等</td>
</tr>
<tr>
<td style="text-align:center">高级特性支持</td>
<td style="text-align:center">中等</td>
<td style="text-align:center">丰富</td>
</tr>
<tr>
<td style="text-align:center">官方文档、Example支持</td>
<td style="text-align:center">中文</td>
<td style="text-align:center">英文</td>
</tr>
<tr>
<td style="text-align:center">处理json速度</td>
<td style="text-align:center">略快</td>
<td style="text-align:center">快</td>
</tr>
</tbody>
</table>
<p>关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。</p>
<h3 id="22-fastjson依赖导入">2.2 fastJson依赖导入</h3>
<p>使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;
	&lt;artifactId&gt;fastjson&lt;/artifactId&gt;
	&lt;version&gt;1.2.35&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="22-使用-fastjson-处理-null">2.2 使用 fastJson 处理 null</h3>
<p>使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承  <code>WebMvcConfigurationSupport</code> 类，然后覆盖 <code>configureMessageConverters</code> 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下：</p>
<pre><code class="language-java">import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.support.config.FastJsonConfig;
import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

@Configuration
public class fastJsonConfig extends WebMvcConfigurationSupport {

    /**
     * 使用阿里 FastJson 作为JSON MessageConverter
     * @param converters
     */
    @Override
    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();
        FastJsonConfig config = new FastJsonConfig();
        config.setSerializerFeatures(
                // 保留map空的字段
                SerializerFeature.WriteMapNullValue,
                // 将String类型的null转成&quot;&quot;
                SerializerFeature.WriteNullStringAsEmpty,
                // 将Number类型的null转成0
                SerializerFeature.WriteNullNumberAsZero,
                // 将List类型的null转成[]
                SerializerFeature.WriteNullListAsEmpty,
                // 将Boolean类型的null转成false
                SerializerFeature.WriteNullBooleanAsFalse,
                // 避免循环引用
                SerializerFeature.DisableCircularReferenceDetect);

        converter.setFastJsonConfig(config);
        converter.setDefaultCharset(Charset.forName(&quot;UTF-8&quot;));
        List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;();
        // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = &quot;application/json&quot;
        mediaTypeList.add(MediaType.APPLICATION_JSON);
        converter.setSupportedMediaTypes(mediaTypeList);
        converters.add(converter);
    }
}
</code></pre>
<h2 id="3-封装统一返回的数据结构">3. 封装统一返回的数据结构</h2>
<p>以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。</p>
<h3 id="31-定义统一的-json-结构">3.1 定义统一的 json 结构</h3>
<p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p>
<pre><code class="language-java">public class JsonResult&lt;T&gt; {

    private T data;
    private String code;
    private String msg;

    /**
     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！
     */
    public JsonResult() {
        this.code = &quot;0&quot;;
        this.msg = &quot;操作成功！&quot;;
    }

    /**
     * 若没有数据返回，可以人为指定状态码和提示信息
     * @param code
     * @param msg
     */
    public JsonResult(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    /**
     * 有数据返回时，状态码为0，默认提示信息为：操作成功！
     * @param data
     */
    public JsonResult(T data) {
        this.data = data;
        this.code = &quot;0&quot;;
        this.msg = &quot;操作成功！&quot;;
    }

    /**
     * 有数据返回，状态码为0，人为指定提示信息
     * @param data
     * @param msg
     */
    public JsonResult(T data, String msg) {
        this.data = data;
        this.code = &quot;0&quot;;
        this.msg = msg;
    }
    // 省略get和set方法
}
</code></pre>
<h3 id="32-修改-controller-中的返回值类型及测试">3.2 修改 Controller 中的返回值类型及测试</h3>
<p>由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/jsonresult&quot;)
public class JsonResultController {

    @RequestMapping(&quot;/user&quot;)
    public JsonResult&lt;User&gt; getUser() {
        User user = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);
        return new JsonResult&lt;&gt;(user);
    }

    @RequestMapping(&quot;/list&quot;)
    public JsonResult&lt;List&gt; getUserList() {
        List&lt;User&gt; userList = new ArrayList&lt;&gt;();
        User user1 = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);
        User user2 = new User(2, &quot;达人课&quot;, &quot;123456&quot;);
        userList.add(user1);
        userList.add(user2);
        return new JsonResult&lt;&gt;(userList, &quot;获取用户列表成功&quot;);
    }

    @RequestMapping(&quot;/map&quot;)
    public JsonResult&lt;Map&gt; getMap() {
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);
        User user = new User(1, &quot;倪升武&quot;, null);
        map.put(&quot;作者信息&quot;, user);
        map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);
        map.put(&quot;CSDN地址&quot;, null);
        map.put(&quot;粉丝数量&quot;, 4153);
        return new JsonResult&lt;&gt;(map);
    }
}
</code></pre>
<p>我们重新在浏览器中输入：<code>localhost:8080/jsonresult/user</code> 返回 json 如下：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:{&quot;id&quot;:1,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;倪升武&quot;},&quot;msg&quot;:&quot;操作成功！&quot;}
</code></pre>
<p>输入：<code>localhost:8080/jsonresult/list</code>，返回 json 如下：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:[{&quot;id&quot;:1,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;倪升武&quot;},{&quot;id&quot;:2,&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;达人课&quot;}],&quot;msg&quot;:&quot;获取用户列表成功&quot;}
</code></pre>
<p>输入：<code>localhost:8080/jsonresult/map</code>，返回 json 如下：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:{&quot;作者信息&quot;:{&quot;id&quot;:1,&quot;password&quot;:&quot;&quot;,&quot;username&quot;:&quot;倪升武&quot;},&quot;CSDN地址&quot;:null,&quot;粉丝数量&quot;:4153,&quot;博客地址&quot;:&quot;http://blog.itcodai.com&quot;},&quot;msg&quot;:&quot;操作成功！&quot;}
</code></pre>
<p>通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。</p>
<h2 id="4-总结-2">4. 总结</h2>
<p>本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。<br>
课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="使用slf4j进行日志记录"></a></p>
<h1 id="spring-boot使用slf4j进行日志记录">Spring Boot使用slf4j进行日志记录</h1>
<p>在开发中，我们经常使用 <code>System.out.println()</code> 来打印一些信息，但是这样不好，因为大量的使用 <code>System.out</code> 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。</p>
<h2 id="1-slf4j-介绍">1. slf4j 介绍</h2>
<p>引用百度百科里的一段话：</p>
<blockquote>
<p>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p>
</blockquote>
<p>这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。</p>
<p>正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j：</p>
<blockquote>
<p>1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
</blockquote>
<p>“强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用  LoggerFactory 创建即可。</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Test {
    private static final Logger logger = LoggerFactory.getLogger(Test.class);
    // ……
}
</code></pre>
<h2 id="2-applicationyml-中对日志的配置">2. application.yml 中对日志的配置</h2>
<p>Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。<code>application.yml</code> 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 <code>application.properties</code> 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。</p>
<p>我们看一下 application.yml 文件中对日志的配置：</p>
<pre><code class="language-xml">logging:
  config: logback.xml
  level:
    com.itcodai.course03.dao: trace
</code></pre>
<p><code>logging.config</code> 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 <code>logback.xml</code> 文件，关于日志的相关配置信息，都放在 <code>logback.xml</code> 文件中了。<code>logging.level</code> 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 <code>com.itcodai.course03.dao</code> 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。</p>
<p>常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。</p>
<h2 id="3-logbackxml-配置文件解析">3. logback.xml 配置文件解析</h2>
<p>在上面 <code>application.yml</code> 文件中，我们指定了日志配置文件 <code>logback.xml</code>，<code>logback.xml</code> 文件中主要用来做日志的相关配置。在 <code>logback.xml</code> 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下：</p>
<h3 id="31-定义日志输出格式和存储路径">3.1 定义日志输出格式和存储路径</h3>
<pre><code class="language-xml">&lt;configuration&gt;
	&lt;property name=&quot;LOG_PATTERN&quot; value=&quot;%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&quot; /&gt;
	&lt;property name=&quot;FILE_PATH&quot; value=&quot;D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log&quot; /&gt;
&lt;/configuration&gt;
</code></pre>
<p>我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 <code>%date</code> 表示日期，<code>%thread</code> 表示线程名，<code>%-5level</code> 表示级别从左显示5个字符宽度，<code>%logger{36}</code>  表示 logger 名字最长36个字符，<code>%msg</code> 表示日志消息，<code>%n</code> 是换行符。</p>
<p>然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。<code>%i</code> 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。</p>
<h3 id="32-定义控制台输出">3.2 定义控制台输出</h3>
<pre><code class="language-xml">&lt;configuration&gt;
	&lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
		&lt;encoder&gt;
            &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;
			&lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
&lt;/configuration&gt;
</code></pre>
<p>使用 <code>&lt;appender&gt;</code> 节点设置个控制台输出（<code>class=&quot;ch.qos.logback.core.ConsoleAppender&quot;</code>）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 <code>${}</code> 引用进来即可。</p>
<h3 id="33-定义日志文件的相关参数">3.3 定义日志文件的相关参数</h3>
<pre><code class="language-xml">&lt;configuration&gt;
	&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
		&lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
			&lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt;
			&lt;fileNamePattern&gt;${FILE_PATH}&lt;/fileNamePattern&gt;
			&lt;!-- 日志保存15天 --&gt;
			&lt;maxHistory&gt;15&lt;/maxHistory&gt;
			&lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;
				&lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt;
				&lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;
			&lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
		&lt;/rollingPolicy&gt;

		&lt;encoder&gt;
			&lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt;
			&lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt;
		&lt;/encoder&gt;
	&lt;/appender&gt;
&lt;/configuration&gt;
</code></pre>
<p>使用 <code>&lt;appender&gt;</code> 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。</p>
<h3 id="34-定义日志输出级别">3.4 定义日志输出级别</h3>
<pre><code class="language-xml">&lt;configuration&gt;
	&lt;logger name=&quot;com.itcodai.course03&quot; level=&quot;INFO&quot; /&gt;
	&lt;root level=&quot;INFO&quot;&gt;
		&lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
		&lt;appender-ref ref=&quot;FILE&quot; /&gt;
	&lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<p>有了上面那些定义后，最后我们使用 <code>&lt;logger&gt;</code> 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 <code>&lt;root&gt;</code> 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。</p>
<h2 id="4-使用logger在项目中打印日志">4. 使用Logger在项目中打印日志</h2>
<p>在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/test&quot;)
public class TestController {

    private final static Logger logger = LoggerFactory.getLogger(TestController.class);

    @RequestMapping(&quot;/log&quot;)
    public String testLog() {
        logger.debug(&quot;=====测试日志debug级别打印====&quot;);
        logger.info(&quot;======测试日志info级别打印=====&quot;);
        logger.error(&quot;=====测试日志error级别打印====&quot;);
        logger.warn(&quot;======测试日志warn级别打印=====&quot;);

        // 可以使用占位符打印出一些参数信息
        String str1 = &quot;blog.itcodai.com&quot;;
        String str2 = &quot;blog.csdn.net/eson_15&quot;;
        logger.info(&quot;======倪升武的个人博客：{}；倪升武的CSDN博客：{}&quot;, str1, str2);

        return &quot;success&quot;;
    }
}
</code></pre>
<p>启动该项目，在浏览器中输入 <code>localhost:8080/test/log</code> 后可以看到控制台的日志记录：</p>
<blockquote>
<p>==<mark><mark>测试日志info级别打印</mark></mark>=<br>
=<mark><mark>测试日志error级别打印</mark></mark><br>
==<mark><mark>测试日志warn级别打印</mark></mark>=<br>
======倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15</p>
</blockquote>
<p>因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\logs\course03\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。</p>
<h2 id="5-总结">5. 总结</h2>
<p>本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 <code>logback.xml</code> 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。<br>
课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="项目属性配置"></a></p>
<h1 id="spring-boot中的项目属性配置">Spring Boot中的项目属性配置</h1>
<p>我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 <code>application.yml</code> 文件中。</p>
<h2 id="1-少量配置信息的情形">1. 少量配置信息的情形</h2>
<p>举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置：</p>
<pre><code class="language-xml">server:
  port: 8001

# 配置微服务的地址
url:
  # 订单微服务的地址
  orderUrl: http://localhost:8002
</code></pre>
<p>然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 <code>@Value</code> 注解来解决。在对应的类中加上一个属性，在属性上使用 <code>@Value</code> 注解即可获取到配置文件中的配置信息，如下：</p>
<pre><code class="language-java">import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/test&quot;)
public class ConfigController {

    private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class);

    @Value(&quot;${url.orderUrl}&quot;)
    private String orderUrl;
    
    @RequestMapping(&quot;/config&quot;)
    public String testConfig() {
        LOGGER.info(&quot;=====获取的订单服务地址为：{}&quot;, orderUrl);
        return &quot;success&quot;;
    }
}
</code></pre>
<p><code>@Value</code> 注解上通过 <code>${key}</code> 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 <code>localhost:8080/test/config</code> 请求服务后，可以看到控制台会打印出订单服务的地址：</p>
<pre><code>=====获取的订单服务地址为：http://localhost:8002
</code></pre>
<p>说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。</p>
<h2 id="2-多个配置信息的情形">2. 多个配置信息的情形</h2>
<p>这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 <code>@Value</code> 注解引入相应的微服务地址的话，太过于繁琐，也不科学。</p>
<p>所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好：</p>
<pre><code class="language-xml"># 配置多个微服务的地址
url:
  # 订单微服务的地址
  orderUrl: http://localhost:8002
  # 用户微服务的地址
  userUrl: http://localhost:8003
  # 购物车微服务的地址
  shoppingUrl: http://localhost:8004
</code></pre>
<p>也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 <code>MicroServiceUrl</code> 类来专门保存微服务的 url，如下：</p>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;url&quot;)
public class MicroServiceUrl {

    private String orderUrl;
    private String userUrl;
    private String shoppingUrl;
    // 省去get和set方法
}
</code></pre>
<p>细心的朋友应该可以看到，使用 <code>@ConfigurationProperties</code> 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 <code>@Component</code> 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。</p>
<p>需要注意的是，使用 <code>@ConfigurationProperties</code> 注解需要导入它的依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
	&lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 <code>@Resource</code> 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/test&quot;)
public class TestController {

    private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class);

    @Resource
    private MicroServiceUrl microServiceUrl;
    
    @RequestMapping(&quot;/config&quot;)
    public String testConfig() {
        LOGGER.info(&quot;=====获取的订单服务地址为：{}&quot;, microServiceUrl.getOrderUrl());
        LOGGER.info(&quot;=====获取的用户服务地址为：{}&quot;, microServiceUrl.getUserUrl());
        LOGGER.info(&quot;=====获取的购物车服务地址为：{}&quot;, microServiceUrl.getShoppingUrl());

        return &quot;success&quot;;
    }
}
</code></pre>
<p>再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容：</p>
<pre><code>=====获取的订单服务地址为：http://localhost:8002
=====获取的订单服务地址为：http://localhost:8002
=====获取的用户服务地址为：http://localhost:8003
=====获取的购物车服务地址为：http://localhost:8004
</code></pre>
<h2 id="3-指定项目配置文件">3. 指定项目配置文件</h2>
<p>我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。</p>
<p>最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。</p>
<p>我们新建两个配置文件： <code>application-dev.yml</code> 和 <code>application-pro.yml</code>，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002.</p>
<pre><code class="language-xml"># 开发环境配置文件
server:
  port: 8001
</code></pre>
<pre><code class="language-xml"># 开发环境配置文件
server:
  port: 8002
</code></pre>
<p>然后在 <code>application.yml</code> 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 <code>applicationn-dev.yml</code> 文件，如下：</p>
<pre><code class="language-xml">spring:
  profiles:
    active:
    - dev
</code></pre>
<p>这样就可以在开发的时候，指定读取  <code>application-dev.yml</code> 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 <code>application.yml</code> 中指定的文件改成 <code>application-pro.yml</code> 即可，然后使用 8002 端口访问，非常方便。</p>
<h2 id="4-总结-3">4. 总结</h2>
<p>本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。<br>
课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="MVC支持"></a></p>
<h1 id="spring-boot中的mvc支持">Spring Boot中的MVC支持</h1>
<p>Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、<code>@RequestParam</code> 以及 <code>@RequestBody</code>。主要介绍这几个注解常用的使用方式和特点。</p>
<h2 id="1-restcontroller">1. @RestController</h2>
<p><code>@RestController</code> 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。</p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
    String value() default &quot;&quot;;
}
</code></pre>
<p>可以看出， <code>@RestController</code> 注解包含了原来的 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解，使用过 Spring 的朋友对 <code>@Controller</code> 注解已经非常了解了，这里不再赘述， <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式。所以 <code>@RestController</code> 可以看作是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，相当于偷个懒，我们使用 <code>@RestController</code> 之后就不用再使用 <code>@Controller</code> 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用<code>@RestController</code> 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用<code>@RestController</code>了，比如：</p>
<pre><code class="language-java">public String getUser() {
	return &quot;user&quot;;
}
</code></pre>
<p>其实是需要返回到 user.html 页面的，如果使用 <code>@RestController</code> 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 <code>@Controller</code> 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。</p>
<h2 id="2-requestmapping">2. @RequestMapping</h2>
<p><code>@RequestMapping</code> 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。</p>
<p>该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。</p>
<ul>
<li>value 属性：指定请求的实际地址，value 可以省略不写</li>
<li>method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET</li>
<li>produces属性：指定返回内容类型，如 produces = &quot;application/json; charset=UTF-8&quot;</li>
</ul>
<p><code>@RequestMapping</code> 注解比较简单，举个例子：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/test&quot;, produces = &quot;application/json; charset=UTF-8&quot;)
public class TestController {

    @RequestMapping(value = &quot;/get&quot;, method = RequestMethod.GET)
    public String testGet() {
        return &quot;success&quot;;
    }
}
</code></pre>
<p>这个很简单，启动项目在浏览器中输入 <code>localhost:8080/test/get</code> 测试一下即可。</p>
<p>针对四种不同的请求方式，是有相应注解的，不用每次在 <code>@RequestMapping</code> 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 <code>@GetMapping(&quot;/get&quot;)</code> 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 <code>@PutMapping</code>、<code>@PostMapping</code> 和 <code>DeleteMapping</code>。</p>
<h2 id="3-pathvariable">3. @PathVariable</h2>
<p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解。如下：</p>
<pre><code class="language-java">@GetMapping(&quot;/user/{id}&quot;)
public String testPathVariable(@PathVariable Integer id) {
	System.out.println(&quot;获取到的id为：&quot; + id);
	return &quot;success&quot;;
}
</code></pre>
<p>这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 <code>@PathVariable</code> 中的 value 属性来指定对应关系。如下：</p>
<pre><code class="language-java">@RequestMapping(&quot;/user/{idd}&quot;)
public String testPathVariable(@PathVariable(value = &quot;idd&quot;) Integer id) {
	System.out.println(&quot;获取到的id为：&quot; + id);
	return &quot;success&quot;;
}
</code></pre>
<p>对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：<code>/xxx/{id}/user</code>。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如：</p>
<pre><code class="language-java">@GetMapping(&quot;/user/{idd}/{name}&quot;)
    public String testPathVariable(@PathVariable(value = &quot;idd&quot;) Integer id, @PathVariable String name) {
        System.out.println(&quot;获取到的id为：&quot; + id);
        System.out.println(&quot;获取到的name为：&quot; + name);
        return &quot;success&quot;;
    }
</code></pre>
<p>运行项目，在浏览器中请求 <code>localhost:8080/test/user/2/zhangsan</code> 可以看到控制台输出如下信息：</p>
<pre><code>获取到的id为：2
获取到的name为：zhangsan
</code></pre>
<p>所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。</p>
<h2 id="4-requestparam">4. @RequestParam</h2>
<p><code>@RequestParam</code> 注解顾名思义，也是获取请求参数的，上面我们介绍了 <code>@PathValiable</code> 注解也是获取请求参数的，那么 <code>@RequestParam</code> 和 <code>@PathVariable</code> 有什么不同呢？主要区别在于： <code>@PathValiable</code> 是从 url 模板中获取参数值， 即这种风格的 url：<code>http://localhost:8080/user/{id}</code> ；而 <code>@RequestParam</code> 是从 request 里面获取参数值，即这种风格的 url：<code>http://localhost:8080/user?id=1</code>  。我们使用该 url 带上参数 id 来测试一下如下代码：</p>
<pre><code class="language-java">@GetMapping(&quot;/user&quot;)
public String testRequestParam(@RequestParam Integer id) {
	System.out.println(&quot;获取到的id为：&quot; + id);
	return &quot;success&quot;;
}
</code></pre>
<p>可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：<code>http://localhost:8080/user?idd=1</code></p>
<pre><code class="language-java">@RequestMapping(&quot;/user&quot;)
public String testRequestParam(@RequestParam(value = &quot;idd&quot;, required = false) Integer id) {
	System.out.println(&quot;获取到的id为：&quot; + id);
	return &quot;success&quot;;
}
</code></pre>
<p>除了 value 属性外，还有个两个属性比较常用：</p>
<ul>
<li>required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。</li>
<li>defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。</li>
</ul>
<p>从 url 中可以看出，<code>@RequestParam</code> 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 <code>@RequestParam</code> 来接收，用法和上面一样。</p>
<pre><code class="language-java">@PostMapping(&quot;/form1&quot;)
    public String testForm(@RequestParam String username, @RequestParam String password) {
        System.out.println(&quot;获取到的username为：&quot; + username);
        System.out.println(&quot;获取到的password为：&quot; + password);
        return &quot;success&quot;;
    }
</code></pre>
<p>我们使用 postman 来模拟一下表单提交，测试一下接口：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200215043749282.png" alt="使用postman测试表单提交" loading="lazy"></figure>
<p>那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 <code>@RequestParam</code> 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。</p>
<pre><code class="language-java">public class User {
	private String username;
	private String password;
	// set get
}
</code></pre>
<p>使用实体接收的话，我们不能在前面加 <code>@RequestParam</code> 注解了，直接使用即可。</p>
<pre><code class="language-java">@PostMapping(&quot;/form2&quot;)
    public String testForm(User user) {
        System.out.println(&quot;获取到的username为：&quot; + user.getUsername());
        System.out.println(&quot;获取到的password为：&quot; + user.getPassword());
        return &quot;success&quot;;
    }
</code></pre>
<p>使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。</p>
<h2 id="5-requestbody">5. @RequestBody</h2>
<p><code>@RequestBody</code> 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 <code>@RequestBody</code> 接收会非常方便。例如：</p>
<pre><code class="language-java">public class User {
	private String username;
	private String password;
	// set get
}
</code></pre>
<pre><code class="language-java">@PostMapping(&quot;/user&quot;)
public String testRequestBody(@RequestBody User user) {
	System.out.println(&quot;获取到的username为：&quot; + user.getUsername());
	System.out.println(&quot;获取到的password为：&quot; + user.getPassword());
	return &quot;success&quot;;
}
</code></pre>
<p>我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200215043853532.png" alt="使用Postman测试requestBody" loading="lazy"></figure>
<p>同时看一下后台控制台输出的日志：</p>
<pre><code>获取到的username为：倪升武
获取到的password为：123456
</code></pre>
<p>可以看出，<code>@RequestBody</code> 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。</p>
<h2 id="6-总结">6. 总结</h2>
<p>本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 <code>@RestController</code>、 <code>@RequestMapping</code>、<code>@PathVariable</code>、 <code>@RequestParam</code> 和 <code>@RequestBody</code> 四个注解的使用方式，由于 <code>@RestController</code> 中集成了 <code>@ResponseBody</code> 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成Swagger2展现在线接口文档"></a></p>
<h1 id="spring-boot集成-swagger2-展现在线接口文档">Spring Boot集成 Swagger2 展现在线接口文档</h1>
<h2 id="1-swagger-简介">1. Swagger 简介</h2>
<h3 id="11-解决的问题">1.1 解决的问题</h3>
<p>随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。</p>
<p>那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。</p>
<h3 id="12-swagger-官方">1.2 Swagger 官方</h3>
<p>我们打开 <a href="https://swagger.io/">Swagger 官网</a>，官方对 Swagger 的定义为：</p>
<blockquote>
<p>The Best APIs are Built with Swagger Tools</p>
</blockquote>
<p>翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200215043936444.png" alt="官方对swagger的定位" loading="lazy"></figure>
<p>本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。</p>
<h2 id="2-swagger2-的-maven-依赖">2. Swagger2 的 maven 依赖</h2>
<p>使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
	&lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;io.springfox&lt;/groupId&gt;
	&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
	&lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="3-swagger2-的配置">3. Swagger2 的配置</h2>
<p>使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 <code>@Configuration</code> 注解外，还需要添加 <code>@EnableSwagger2</code> 注解。</p>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @author shengwu ni
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                // 指定构建api文档的详细信息的方法：apiInfo()
                .apiInfo(apiInfo())
                .select()
                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itcodai.course06.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * 构建api文档的详细信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                // 设置页面标题
                .title(&quot;Spring Boot集成Swagger2接口总览&quot;)
                // 设置接口描述
                .description(&quot;跟武哥一起学Spring Boot第06课&quot;)
                // 设置联系方式
                .contact(&quot;倪升武，&quot; + &quot;CSDN：http://blog.csdn.net/eson_15&quot;)
                // 设置版本
                .version(&quot;1.0&quot;)
                // 构建
                .build();
    }
}
</code></pre>
<p>在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code>，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200215044013383.png" alt="swagger2页面" loading="lazy"></figure>
<p>结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。</p>
<p>【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。</p>
<figure data-type="image" tabindex="10"><img src="http://p99jlm9k5.bkt.clouddn.com/blog/images/1/error.png" alt="错误页面-倪升武的博客-图2" loading="lazy"></figure>
<h2 id="4-swagger2-的使用">4. Swagger2 的使用</h2>
<p>上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。</p>
<h3 id="41-实体类注解">4.1 实体类注解</h3>
<p>本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解，同时为后面的测试做准备。</p>
<pre><code class="language-java">import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel(value = &quot;用户实体类&quot;)
public class User {

    @ApiModelProperty(value = &quot;用户唯一标识&quot;)
    private Long id;

    @ApiModelProperty(value = &quot;用户姓名&quot;)
    private String username;

    @ApiModelProperty(value = &quot;用户密码&quot;)
    private String password;

	// 省略set和get方法
}
</code></pre>
<p>解释下 <code>@ApiModel</code> 和 <code>@ApiModelProperty</code> 注解：</p>
<blockquote>
<p><code>@ApiModel</code> 注解用于实体类，表示对类进行说明，用于参数用实体类接收。<br>
<code>@ApiModelProperty</code> 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。</p>
</blockquote>
<p>该注解在在线 API 文档中的具体效果在下文说明。</p>
<h3 id="42-controller-类中相关注解">4.2 Controller 类中相关注解</h3>
<p>我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。</p>
<pre><code class="language-java">import com.itcodai.course06.entiy.JsonResult;
import com.itcodai.course06.entiy.User;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping(&quot;/swagger&quot;)
@Api(value = &quot;Swagger2 在线接口文档&quot;)
public class TestController {

    @GetMapping(&quot;/get/{id}&quot;)
    @ApiOperation(value = &quot;根据用户唯一标识获取用户信息&quot;)
    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = &quot;用户唯一标识&quot;) Long id) {
        // 模拟数据库中根据id获取User信息
        User user = new User(id, &quot;倪升武&quot;, &quot;123456&quot;);
        return new JsonResult(user);
    }
}
</code></pre>
<p>我们来学习一下 <code>@Api</code> 、 <code>@ApiOperation</code> 和 <code>@ApiParam</code> 注解。</p>
<blockquote>
<p><code>@Api</code> 注解用于类上，表示标识这个类是 swagger 的资源。<br>
<code>@ApiOperation</code> 注解用于方法，表示一个 http 请求的操作。<br>
<code>@ApiParam</code> 注解用于参数上，用来标明参数信息。</p>
</blockquote>
<p>这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下 Swagger 页面的接口状态。</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200215044156305.png" alt="swagger接口展示" loading="lazy"></figure>
<p>可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据：</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200215044226292.png" alt="返回数据测试" loading="lazy"></figure>
<p>可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。</p>
<pre><code class="language-java">@PostMapping(&quot;/insert&quot;)
    @ApiOperation(value = &quot;添加用户信息&quot;)
    public JsonResult&lt;Void&gt; insertUser(@RequestBody @ApiParam(value = &quot;用户信息&quot;) User user) {
        // 处理添加逻辑
        return new JsonResult&lt;&gt;();
    }
</code></pre>
<p>重启项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 看一下效果：</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200215044256579.png" alt="swagger接口展示" loading="lazy"></figure>
<h2 id="5-总结-2">5. 总结</h2>
<p>OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成Thymeleaf模板引擎"></a></p>
<h1 id="spring-boot集成thymeleaf模板引擎">Spring Boot集成Thymeleaf模板引擎</h1>
<h2 id="1-thymeleaf-介绍">1. Thymeleaf 介绍</h2>
<blockquote>
<p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。<br>
Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。</p>
</blockquote>
<p>以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。</p>
<p>什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如：</p>
<pre><code class="language-html">&lt;div class=&quot;ui right aligned basic segment&quot;&gt;
      &lt;div class=&quot;ui orange basic label&quot; th:text=&quot;${blog.flag}&quot;&gt;静态原创信息&lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;ui center aligned header&quot; th:text=&quot;${blog.title}&quot;&gt;这是静态标题&lt;/h2&gt;
</code></pre>
<p>类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，<code>th:text</code> 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 <code>th:text</code>），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。</p>
<h2 id="2-依赖导入">2. 依赖导入</h2>
<p>在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入：</p>
<pre><code class="language-html">&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
</code></pre>
<h2 id="3-thymeleaf相关配置">3. Thymeleaf相关配置</h2>
<p>因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。</p>
<pre><code class="language-yml">spring:
  thymeleaf:
    cache: false #关闭缓存
</code></pre>
<p>否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。</p>
<h2 id="4-thymeleaf-的使用">4. Thymeleaf 的使用</h2>
<h3 id="41-访问静态页面">4.1 访问静态页面</h3>
<p>这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    这是404页面
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们再写一个 controller 来测试一下 404 和 500 页面：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/thymeleaf&quot;)
public class ThymeleafController {

    @RequestMapping(&quot;/test404&quot;)
    public String test404() {
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;/test500&quot;)
    public String test500() {
        int i = 1 / 0;
        return &quot;index&quot;;
    }
}
</code></pre>
<blockquote>
<p>当我们在浏览器中输入 <code>localhost:8080/thymeleaf/test400</code> 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。<br>
当我们在浏览器中输入 <code>localhost:8088/thymeleaf/test505</code> 时，会抛出异常，然后会自动跳转到 500.html 显示。</p>
</blockquote>
<p>【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 <code>@RestController</code> 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 <code>@RestController</code> 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 <code>@RestController</code> 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 <code>@Controller</code> 注解。</p>
<h3 id="42-thymeleaf-中处理对象">4.2 Thymeleaf 中处理对象</h3>
<p>我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如：</p>
<pre><code class="language-java">public class Blogger {
    private Long id;
    private String name;
    private String pass;
	// 省去set和get
}
</code></pre>
<p>然后在controller层中初始化一下：</p>
<pre><code class="language-java">@GetMapping(&quot;/getBlogger&quot;)
public String getBlogger(Model model) {
	Blogger blogger = new Blogger(1L, &quot;倪升武&quot;, &quot;123456&quot;);
	model.addAttribute(&quot;blogger&quot;, blogger);
	return &quot;blogger&quot;;
}
</code></pre>
<p>我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;博主信息&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; th:object=&quot;${blogger}&quot; &gt;
    用户编号：&lt;input name=&quot;id&quot; th:value=&quot;${blogger.id}&quot;/&gt;&lt;br&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${blogger.getName()}&quot; /&gt;&lt;br&gt;
    登陆密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; th:value=&quot;*{pass}&quot; /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以看出，在 thymeleaf 模板中，使用 <code>th:object=&quot;${}&quot;</code> 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下：</p>
<blockquote>
<p>使用 <code>th:value=&quot;*{属性名}&quot;</code><br>
使用 <code>th:value=&quot;${对象.属性名}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象<br>
使用 <code>th:value=&quot;${对象.get方法}&quot;</code>，对象指的是上面使用 <code>th:object</code> 获取的对象</p>
</blockquote>
<p>可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 <code>localhost:8080/thymeleaf/getBlogger</code> 来测试一下数据：</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200215044353803.jpg" alt="thymeleaf中处理对象" loading="lazy"></figure>
<h3 id="43-thymeleaf-中处理-list">4.3 Thymeleaf 中处理 List</h3>
<p>处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。</p>
<pre><code class="language-java">@GetMapping(&quot;/getList&quot;)
public String getList(Model model) {
    Blogger blogger1 = new Blogger(1L, &quot;倪升武&quot;, &quot;123456&quot;);
    Blogger blogger2 = new Blogger(2L, &quot;达人课&quot;, &quot;123456&quot;);
    List&lt;Blogger&gt; list = new ArrayList&lt;&gt;();
    list.add(blogger1);
    list.add(blogger2);
    model.addAttribute(&quot;list&quot;, list);
    return &quot;list&quot;;
}
</code></pre>
<p>接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;博主信息&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;&quot; th:each=&quot;blogger : ${list}&quot; &gt;
    用户编号：&lt;input name=&quot;id&quot; th:value=&quot;${blogger.id}&quot;/&gt;&lt;br&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;password&quot; th:value=&quot;${blogger.name}&quot;/&gt;&lt;br&gt;
    登录密码：&lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;${blogger.getPass()}&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 <code>th:each</code> 进行遍历，<code>${}</code> 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 <code>${对象.属性名}</code> 来获取 list 中对象的属性值，也可以使用 <code>${对象.get方法}</code> 来获取，这点和上面处理对象信息是一样的，但是不能使用 <code>*{属性名}</code> 来获取对象中的属性，thymeleaf 模板获取不到。</p>
<h3 id="44-其他常用-thymeleaf-操作">4.4 其他常用 thymeleaf 操作</h3>
<p>我们来总结一下 thymeleaf 中的一些常用的标签操作，如下：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>th:value</code></td>
<td>给属性赋值</td>
<td><code>&lt;input th:value=&quot;${blog.name}&quot; /&gt;</code></td>
</tr>
<tr>
<td><code>th:style</code></td>
<td>设置样式</td>
<td><code>th:style=&quot;'display:'+@{(${sitrue}?'none':'inline-block')} + ''&quot;</code></td>
</tr>
<tr>
<td><code>th:onclick</code></td>
<td>点击事件</td>
<td><code>th:onclick=&quot;'getInfo()'&quot;</code></td>
</tr>
<tr>
<td><code>th:if</code></td>
<td>条件判断</td>
<td><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td>
</tr>
<tr>
<td><code>th:href</code></td>
<td>超链接</td>
<td><code>&lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt;</code></td>
</tr>
<tr>
<td><code>th:unless</code></td>
<td>条件判断和<code>th:if</code>相反</td>
<td><code>&lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td>
</tr>
<tr>
<td><code>th:switch</code></td>
<td>配合<code>th:case</code></td>
<td><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td>
</tr>
<tr>
<td><code>th:case</code></td>
<td>配合<code>th:switch</code></td>
<td><code>&lt;p th:case=&quot;'admin'&quot;&gt;administator&lt;/p&gt;</code></td>
</tr>
<tr>
<td><code>th:src</code></td>
<td>地址引入</td>
<td><code>&lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td>
</tr>
<tr>
<td><code>th:action</code></td>
<td>表单提交的地址</td>
<td><code>&lt;form th:action=&quot;@{/blogger/update}&quot;&gt;</code></td>
</tr>
</tbody>
</table>
<p>Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html">官方文档（v3.0）</a>。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。</p>
<h2 id="5-总结-3">5. 总结</h2>
<p>Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="全局异常处理"></a></p>
<h1 id="spring-boot中的全局异常处理">Spring Boot中的全局异常处理</h1>
<p>在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。<br>
针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。</p>
<h2 id="1-定义返回的统一-json-结构">1. 定义返回的统一 json 结构</h2>
<p>前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。<br>
这个统一的 json 结构这可以参考<a href="https://gitbook.cn/gitchat/column/5b3c9f35a3442272491a176a">Spring Boot 返回 JSON 数据及数据封装</a>中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下：</p>
<pre><code class="language-java">public class JsonResult {
    /**
     * 异常码
     */
    protected String code;

    /**
     * 异常信息
     */
    protected String msg;
	
    public JsonResult() {
        this.code = &quot;200&quot;;
        this.msg = &quot;操作成功&quot;;
    }
    
    public JsonResult(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }
	// get set
}
</code></pre>
<h2 id="2-处理系统异常">2. 处理系统异常</h2>
<p>新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 <code>@ControllerAdvice</code> 注解即可拦截项目中抛出的异常，如下：</p>
<pre><code class="language-java">@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {
	// 打印log
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    // ……
}
</code></pre>
<p>我们点开 <code>@ControllerAdvice</code> 注解可以看到，<code>@ControllerAdvice</code> 注解包含了 <code>@Component</code> 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 <code>basePackages</code> 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。<code>@ResponseBody</code> 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。<br>
在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 <code>@ExceptionHandler</code> 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。</p>
<h3 id="21-处理参数缺失异常">2.1 处理参数缺失异常</h3>
<p>在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。</p>
<p>参数缺失的时候，会抛出 <code>HttpMessageNotReadableException</code>，我们可以拦截该异常，做一个友好处理，如下：</p>
<pre><code class="language-java">/**
* 缺少请求参数异常
* @param ex HttpMessageNotReadableException
* @return
*/
@ExceptionHandler(MissingServletRequestParameterException.class)
@ResponseStatus(value = HttpStatus.BAD_REQUEST)
public JsonResult handleHttpMessageNotReadableException(
    MissingServletRequestParameterException ex) {
    logger.error(&quot;缺少请求参数，{}&quot;, ex.getMessage());
    return new JsonResult(&quot;400&quot;, &quot;缺少必要的请求参数&quot;);
}
</code></pre>
<p>我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/exception&quot;)
public class ExceptionController {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);

    @PostMapping(&quot;/test&quot;)
    public JsonResult test(@RequestParam(&quot;name&quot;) String name,
                           @RequestParam(&quot;pass&quot;) String pass) {
        logger.info(&quot;name：{}&quot;, name);
        logger.info(&quot;pass：{}&quot;, pass);
        return new JsonResult();
    }
}
</code></pre>
<p>然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下：</p>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/2020021504443480.png" alt="缺失参数异常" loading="lazy"></figure>
<h3 id="22-处理空指针异常">2.2 处理空指针异常</h3>
<p>空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？<br>
先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。<br>
还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。<br>
对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下：</p>
<pre><code class="language-java">@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 空指针异常
     * @param ex NullPointerException
     * @return
     */
    @ExceptionHandler(NullPointerException.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleTypeMismatchException(NullPointerException ex) {
        logger.error(&quot;空指针异常，{}&quot;, ex.getMessage());
        return new JsonResult(&quot;500&quot;, &quot;空指针异常了&quot;);
    }
}
</code></pre>
<p>这个我就不测试了，代码中 ExceptionController 有个 <code>testNullPointException</code> 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;500&quot;,&quot;msg&quot;:&quot;空指针异常了&quot;}
</code></pre>
<h3 id="23-一劳永逸">2.3 一劳永逸？</h3>
<p>当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸：</p>
<pre><code class="language-java">@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    /**
     * 系统异常 预期以外异常
     * @param ex
     * @return
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleUnexpectedServer(Exception ex) {
        logger.error(&quot;系统异常：&quot;, ex);
        return new JsonResult(&quot;500&quot;, &quot;系统发生异常，请联系管理员&quot;);
    }
}
</code></pre>
<p>但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。</p>
<h2 id="3-拦截自定义异常">3. 拦截自定义异常</h2>
<p>在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。</p>
<h3 id="31-定义异常信息">3.1 定义异常信息</h3>
<p>由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如：</p>
<pre><code class="language-java">/**
 * 业务异常提示信息枚举类
 * @author shengwu ni
 */
public enum BusinessMsgEnum {
    /** 参数异常 */
    PARMETER_EXCEPTION(&quot;102&quot;, &quot;参数异常!&quot;),
    /** 等待超时 */
    SERVICE_TIME_OUT(&quot;103&quot;, &quot;服务调用超时！&quot;),
    /** 参数过大 */
    PARMETER_BIG_EXCEPTION(&quot;102&quot;, &quot;输入的图片数量不能超过50张!&quot;),
    /** 500 : 一劳永逸的提示也可以在这定义 */
    UNEXPECTED_EXCEPTION(&quot;500&quot;, &quot;系统发生异常，请联系管理员！&quot;);
    // 还可以定义更多的业务异常

    /**
     * 消息码
     */
    private String code;
    /**
     * 消息内容
     */
    private String msg;

    private BusinessMsgEnum(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }
	// set get方法
}
</code></pre>
<h3 id="32-拦截自定义异常">3.2 拦截自定义异常</h3>
<p>然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下：</p>
<pre><code class="language-java">/**
 * 自定义业务异常
 * @author shengwu ni
 */
public class BusinessErrorException extends RuntimeException {
    
    private static final long serialVersionUID = -7480022450501760611L;

    /**
     * 异常码
     */
    private String code;
    /**
     * 异常提示信息
     */
    private String message;

    public BusinessErrorException(BusinessMsgEnum businessMsgEnum) {
        this.code = businessMsgEnum.code();
        this.message = businessMsgEnum.msg();
    }
	// get set方法
}
</code></pre>
<p>在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。</p>
<pre><code class="language-java">@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    /**
     * 拦截业务异常，返回业务异常信息
     * @param ex
     * @return
     */
    @ExceptionHandler(BusinessErrorException.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleBusinessError(BusinessErrorException ex) {
        String code = ex.getCode();
        String message = ex.getMessage();
        return new JsonResult(code, message);
    }
}
</code></pre>
<p>在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/exception&quot;)
public class ExceptionController {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class);

    @GetMapping(&quot;/business&quot;)
    public JsonResult testException() {
        try {
            int i = 1 / 0;
        } catch (Exception e) {
            throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION);
        }
        return new JsonResult();
    }
}
</code></pre>
<p>运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功：</p>
<pre><code class="language-json">{&quot;code&quot;:&quot;500&quot;,&quot;msg&quot;:&quot;系统发生异常，请联系管理员！&quot;}
</code></pre>
<h2 id="4-总结-4">4. 总结</h2>
<p>本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="切面AOP处理"></a></p>
<h1 id="spring-boot中的切面aop处理">Spring Boot中的切面AOP处理</h1>
<h2 id="1-什么是aop">1. 什么是AOP</h2>
<p>AOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？</p>
<p>对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！</p>
<p>这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。</p>
<h2 id="2-spring-boot-中的-aop-处理">2. Spring Boot 中的 AOP 处理</h2>
<h3 id="21-aop-依赖">2.1 AOP 依赖</h3>
<p>使用AOP，首先需要引入AOP的依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="22-实现-aop-切面">2.2 实现 AOP 切面</h3>
<p>Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个<code>@Aspect</code>注解即可。<code>@Aspect</code> 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。<code>@Component</code> 注解让该类交给 Spring 来管理。</p>
<pre><code class="language-java">@Aspect
@Component
public class LogAspectHandler {

}
</code></pre>
<p>这里主要介绍几个常用的注解及使用：</p>
<blockquote>
<p>1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。<br>
2.@Before：在做某件事之前做的事。<br>
3.@After：在做某件事之后做的事。<br>
4.@AfterReturning：在做某件事之后，对其返回值做增强处理。<br>
5.@AfterThrowing：在做某件事抛出异常时，处理。</p>
</blockquote>
<h4 id="221-pointcut-注解">2.2.1 @Pointcut 注解</h4>
<p><code>@Pointcut</code> 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。</p>
<pre><code class="language-java">@Aspect
@Component
public class LogAspectHandler {

    /**
     * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法
     */
    @Pointcut(&quot;execution(* com.itcodai.course09.controller..*.*(..))&quot;)
    public void pointCut() {}
}
</code></pre>
<p><code>@Pointcut</code> 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 <code>execution()</code>，另一个是使用 <code>annotation()</code>。<br>
以 <code>execution(* com.itcodai.course09.controller..*.*(..)))</code> 表达式为例，语法如下：</p>
<blockquote>
<p><code>execution()</code> 为表达式主体<br>
第一个 <code>*</code> 号的位置：表示返回值类型，<code>*</code> 表示所有类型<br>
包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，<code>com.itcodai.course09.controller</code> 包、子包下所有类的方法<br>
第二个 <code>*</code> 号的位置：表示类名，<code>*</code> 表示所有类<br>
<code>*(..)</code> ：这个星号表示方法名，<code>*</code> 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</p>
</blockquote>
<p><code>annotation()</code> 方式是针对某个注解来定义切面，比如我们对具有<code>@GetMapping</code>注解的方法做切面，可以如下定义切面：</p>
<pre><code class="language-java">@Pointcut(&quot;@annotation(org.springframework.web.bind.annotation.GetMapping)&quot;)
public void annotationCut() {}
</code></pre>
<p>然后使用该切面的话，就会切入注解是 <code>@GetMapping</code> 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@DeleteMapping</code> 等。所以这种按照注解的切入方式在实际项目中也很常用。</p>
<h4 id="222-before-注解">2.2.2 @Before 注解</h4>
<p><code>@Before</code> 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如：</p>
<pre><code class="language-java">@Aspect
@Component
public class LogAspectHandler {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * 在上面定义的切面方法之前执行该方法
     * @param joinPoint jointPoint
     */
    @Before(&quot;pointCut()&quot;)
    public void doBefore(JoinPoint joinPoint) {
        logger.info(&quot;====doBefore方法进入了====&quot;);

        // 获取签名
        Signature signature = joinPoint.getSignature();
        // 获取切入的包名
        String declaringTypeName = signature.getDeclaringTypeName();
        // 获取即将执行的方法名
        String funcName = signature.getName();
        logger.info(&quot;即将执行方法为: {}，属于{}包&quot;, funcName, declaringTypeName);
        
        // 也可以用来记录一些信息，比如获取请求的url和ip
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        // 获取请求url
        String url = request.getRequestURL().toString();
        // 获取请求ip
        String ip = request.getRemoteAddr();
        logger.info(&quot;用户请求的url为：{}，ip地址为：{}&quot;, url, ip);
    }
}
</code></pre>
<p>JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 <code>joinPoint.getArgs()</code> 获取）等等。</p>
<h4 id="223-after-注解">2.2.3 @After 注解</h4>
<p><code>@After</code> 注解和 <code>@Before</code>  注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。</p>
<pre><code class="language-java">@Aspect
@Component
public class LogAspectHandler {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法
     */
    @Pointcut(&quot;execution(* com.itcodai.course09.controller..*.*(..))&quot;)
    public void pointCut() {}

    /**
     * 在上面定义的切面方法之后执行该方法
     * @param joinPoint jointPoint
     */
    @After(&quot;pointCut()&quot;)
    public void doAfter(JoinPoint joinPoint) {

        logger.info(&quot;====doAfter方法进入了====&quot;);
        Signature signature = joinPoint.getSignature();
        String method = signature.getName();
        logger.info(&quot;方法{}已经执行完&quot;, method);
    }
}
</code></pre>
<p>到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/aop&quot;)
public class AopController {

    @GetMapping(&quot;/{name}&quot;)
    public String testAop(@PathVariable String name) {
        return &quot;Hello &quot; + name;
    }
}
</code></pre>
<p>启动项目，在浏览器中输入 <code>localhost:8080/aop/CSDN</code>，观察一下控制台的输出信息：</p>
<pre><code>====doBefore方法进入了====  
即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包  
用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1  
====doAfter方法进入了====  
方法testAop已经执行完
</code></pre>
<p>从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 <code>@Before</code> 和 <code>@After</code> 两个注解的实际作用。</p>
<h4 id="224-afterreturning-注解">2.2.4 @AfterReturning 注解</h4>
<p><code>@AfterReturning</code> 注解和 <code>@After</code> 有些类似，区别在于 <code>@AfterReturning</code> 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如：</p>
<pre><code class="language-java">@Aspect
@Component
public class LogAspectHandler {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强
     * @param joinPoint joinPoint
     * @param result result
     */
    @AfterReturning(pointcut = &quot;pointCut()&quot;, returning = &quot;result&quot;)
    public void doAfterReturning(JoinPoint joinPoint, Object result) {

        Signature signature = joinPoint.getSignature();
        String classMethod = signature.getName();
        logger.info(&quot;方法{}执行完毕，返回参数为：{}&quot;, classMethod, result);
        // 实际项目中可以根据业务做具体的返回值增强
        logger.info(&quot;对返回参数进行业务上的增强：{}&quot;, result + &quot;增强版&quot;);
    }
}
</code></pre>
<p>需要注意的是：在 <code>@AfterReturning</code>注解 中，属性 <code>returning</code> 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 <code>doAfterReturning</code> 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）：</p>
<pre><code>方法testAop执行完毕，返回参数为：Hello CSDN  
对返回参数进行业务上的增强：Hello CSDN增强版
</code></pre>
<h4 id="225-afterthrowing-注解">2.2.5 @AfterThrowing 注解</h4>
<p>顾名思义，<code>@AfterThrowing</code> 注解是当被切方法执行时抛出异常时，会进入 <code>@AfterThrowing</code> 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 <code>throwing</code> 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。</p>
<pre><code class="language-java">/**
 * 使用AOP处理log
 * @author shengwu ni
 * @date 2018/05/04 20:24
 */
@Aspect
@Component
public class LogAspectHandler {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * 在上面定义的切面方法执行抛异常时，执行该方法
     * @param joinPoint jointPoint
     * @param ex ex
     */
    @AfterThrowing(pointcut = &quot;pointCut()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        Signature signature = joinPoint.getSignature();
        String method = signature.getName();
        // 处理异常的逻辑
        logger.info(&quot;执行方法{}出错，异常为：{}&quot;, method, ex);
    }
}
</code></pre>
<p>该方法我就不测试了，大家可以自行测试一下。</p>
<h2 id="3-总结">3. 总结</h2>
<p>本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成MyBatis"></a></p>
<h1 id="spring-boot集成mybatis">Spring Boot集成MyBatis</h1>
<h2 id="1-mybatis-介绍">1. MyBatis 介绍</h2>
<p>大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。</p>
<h2 id="2-mybatis-的配置">2. MyBatis 的配置</h2>
<h2 id="21-依赖导入">2.1 依赖导入</h2>
<p>Spring Boot 集成 MyBatis，需要导入 <code>mybatis-spring-boot-starter</code> 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;mysql&lt;/groupId&gt;
	&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
	&lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>我们点开 <code>mybatis-spring-boot-starter</code> 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。</p>
<pre><code class="language-xml">&lt;!-- 省去其他 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="22-propertiesyml配置">2.2 properties.yml配置</h2>
<p>我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？</p>
<pre><code class="language-xml"># 服务端口号
server:
  port: 8080

# 数据库地址
datasource:
  url: localhost:3306/blog_test

spring:
  datasource: # 数据库配置
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10
    username: root
    password: 123456
    hikari:
      maximum-pool-size: 10 # 最大连接池数
      max-lifetime: 1770000

mybatis:
  # 指定别名设置的包为所有entity
  type-aliases-package: com.itcodai.course10.entity
  configuration:
    map-underscore-to-camel-case: true # 驼峰命名规范
  mapper-locations: # mapper映射文件位置
    - classpath:mapper/*.xml
</code></pre>
<p>我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。</p>
<p>这里说明一下 <code>map-underscore-to-camel-case: true</code>， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：<code>user_name</code>， 那么在实体类中可以定义属性为 <code>userName</code> （甚至可以写成 <code>username</code>，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。</p>
<h2 id="3-基于-xml-的整合">3. 基于 xml 的整合</h2>
<p>使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：<code>classpath:mapper/*.xml</code>，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.itcodai.course10.dao.UserMapper&quot;&gt;
  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.itcodai.course10.entity.User&quot;&gt;

    &lt;id column=&quot;id&quot; jdbcType=&quot;BIGINT&quot; property=&quot;id&quot; /&gt;
    &lt;result column=&quot;user_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot; /&gt;
    &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot; /&gt;
  &lt;/resultMap&gt;
  
   &lt;select id=&quot;getUserByName&quot; resultType=&quot;User&quot; parameterType=&quot;String&quot;&gt;
       select * from user where user_name = #{username}
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， <code>&lt;resultMap&gt;</code> 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。</p>
<p>实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可：</p>
<pre><code class="language-java">User getUserByName(String username);
</code></pre>
<p>中间省略 service 的代码，我们写一个 Controller 来测试一下：</p>
<pre><code class="language-java">@RestController
public class TestController {

    @Resource
    private UserService userService;
    
    @RequestMapping(&quot;/getUserByName/{name}&quot;)
    public User getUserByName(@PathVariable String name) {
        return userService.getUserByName(name);
    }
}
</code></pre>
<p>启动项目，在浏览器中输入：<code>http://localhost:8080/getUserByName/CSDN</code> 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）：</p>
<pre><code class="language-json">{&quot;id&quot;:2,&quot;username&quot;:&quot;CSDN&quot;,&quot;password&quot;:&quot;123456&quot;}
</code></pre>
<p>这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 <code>@Mapper</code> 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 <code>@Mapper</code> 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加<code>@MaperScan</code> 注解，来扫描一个包下的所有 mapper。如下：</p>
<pre><code class="language-java">@SpringBootApplication
@MapperScan(&quot;com.itcodai.course10.dao&quot;)
public class Course10Application {

	public static void main(String[] args) {
		SpringApplication.run(Course10Application.class, args);
	}
}
</code></pre>
<p>这样的话，<code>com.itcodai.course10.dao</code> 包下的所有 mapper 都会被扫描到了。</p>
<h2 id="4-基于注解的整合">4. 基于注解的整合</h2>
<p>基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 <code>@Select</code>， <code>@Insert</code>， <code>@Update</code>， <code>Delete</code> 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子：</p>
<pre><code class="language-java">@Select(&quot;select * from user where id = #{id}&quot;)
User getUser(Long id);
</code></pre>
<p>这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 <code>@Param</code> 注解来指定每一个参数的对应关系，如下：</p>
<pre><code class="language-java">@Select(&quot;select * from user where id = #{id} and user_name=#{name}&quot;)
User getUserByIdAndName(@Param(&quot;id&quot;) Long id, @Param(&quot;name&quot;) String username);
</code></pre>
<p>可以看出，<code>@Param</code> 指定的参数应该要和 sql 中 <code>#{}</code> 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。</p>
<p>有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 <code>@Results</code> 注解来解决。</p>
<pre><code class="language-java">@Select(&quot;select * from user where id = #{id}&quot;)
@Results({
        @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),
        @Result(property = &quot;password&quot;, column = &quot;password&quot;)
})
User getUser(Long id);
</code></pre>
<p><code>@Results</code> 中的 <code>@Result</code> 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。</p>
<p>当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 <code>@ResultMap</code> 注解来替代 <code>@Results</code> 注解，如下：</p>
<pre><code class="language-java">@Select(&quot;select * from user where id = #{id}&quot;)
@ResultMap(&quot;BaseResultMap&quot;)
User getUser(Long id);
</code></pre>
<p><code>@ResultMap</code> 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 <code>&lt;resultMap&gt;</code> 时对应的 id 值：</p>
<pre><code class="language-xml">&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.itcodai.course10.entity.User&quot;&gt;
</code></pre>
<p>这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。</p>
<h2 id="5-总结-4">5. 总结</h2>
<p>本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="事务配置管理"></a></p>
<h1 id="spring-boot事务配置管理">Spring Boot事务配置管理</h1>
<h2 id="1-事务相关">1. 事务相关</h2>
<p>场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。</p>
<p>事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。</p>
<p>事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。</p>
<h2 id="2-spring-boot-事务配置">2. Spring Boot 事务配置</h2>
<h3 id="21-依赖导入-2">2.1 依赖导入</h3>
<p>在 Spring Boot 中使用事务，需要导入 mysql 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 <code>@Transactional</code> 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。</p>
<h3 id="22-事务的测试">2.2 事务的测试</h3>
<p>我们首先在数据库表中插入一条数据：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">user_name</th>
<th style="text-align:center">password</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">倪升武</td>
<td style="text-align:center">123456</td>
</tr>
</tbody>
</table>
<p>然后我们写一个插入的 mapper：</p>
<pre><code class="language-java">public interface UserMapper {

    @Insert(&quot;insert into user (user_name, password) values (#{username}, #{password})&quot;)
    Integer insertUser(User user);
}
</code></pre>
<p>OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserMapper userMapper;

    @Override
    @Transactional
    public void isertUser(User user) {
        // 插入用户信息
        userMapper.insertUser(user);
        // 手动抛出异常
        throw new RuntimeException();
    }
}
</code></pre>
<p>我们来测试一下：</p>
<pre><code class="language-java">@RestController
public class TestController {

    @Resource
    private UserService userService;

    @PostMapping(&quot;/adduser&quot;)
    public String addUser(@RequestBody User user) throws Exception {
        if (null != user) {
            userService.isertUser(user);
            return &quot;success&quot;;
        } else {
            return &quot;false&quot;;
        }
    }
}
</code></pre>
<p>我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此……</p>
<h2 id="3-常见问题总结">3. 常见问题总结</h2>
<p>从上面的内容中可以看出，Spring Boot 中使用事务非常简单，<code>@Transactional</code> 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。</p>
<p>这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。</p>
<h3 id="31-异常并没有被-捕获-到">3.1 异常并没有被 ”捕获“ 到</h3>
<p>首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserMapper userMapper;
    
    @Override
    @Transactional
    public void isertUser2(User user) throws Exception {
        // 插入用户信息
        userMapper.insertUser(user);
        // 手动抛出异常
        throw new SQLException(&quot;数据库异常&quot;);
    }
}
</code></pre>
<p>我们看上面这个代码，其实并没有什么问题，手动抛出一个 <code>SQLException</code> 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。</p>
<p>那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 <code>@Transactional</code> 注解中使用 <code>rollbackFor</code> 属性来指定异常，比如 <code>@Transactional(rollbackFor = Exception.class)</code>，这样就没有问题了，所以在实际项目中，一定要指定异常。</p>
<h3 id="32-异常被-吃-掉">3.2 异常被 ”吃“ 掉</h3>
<p>这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try...catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserMapper userMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void isertUser3(User user) {
        try {
            // 插入用户信息
            userMapper.insertUser(user);
            // 手动抛出异常
            throw new SQLException(&quot;数据库异常&quot;);
        } catch (Exception e) {
			// 异常处理逻辑
        }
    }
}
</code></pre>
<p>读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try...catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。</p>
<p>那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。</p>
<h3 id="33-事务的范围">3.3 事务的范围</h3>
<p>事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。</p>
<p>我来写个 demo：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Resource
    private UserMapper userMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public synchronized void isertUser4(User user) {
        // 实际中的具体业务……
        userMapper.insertUser(user);
    }
}
</code></pre>
<p>可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。</p>
<p>但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。</p>
<p>从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。</p>
<p>这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。</p>
<h2 id="4-总结-5">4. 总结</h2>
<p>本章主要总结了 Spring Boot 中如何使用事务，只要使用 <code>@Transactional</code> 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="使用监听器"></a></p>
<h1 id="spring-boot中使用监听器">Spring Boot中使用监听器</h1>
<h2 id="1-监听器介绍">1. 监听器介绍</h2>
<p>什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。</p>
<h2 id="2-spring-boot中监听器的使用">2. Spring Boot中监听器的使用</h2>
<p>web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。</p>
<h3 id="21-监听servlet上下文对象">2.1 监听Servlet上下文对象</h3>
<p>监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。</p>
<p>针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。</p>
<p>下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据：</p>
<pre><code class="language-java">@Service
public class UserService {

    /**
     * 获取用户信息
     * @return
     */
    public User getUser() {
        // 实际中会根据具体的业务场景，从数据库中查询对应的信息
        return new User(1L, &quot;倪升武&quot;, &quot;123456&quot;);
    }
}
</code></pre>
<p>然后写一个监听器，实现 <code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code> 接口，重写 <code>onApplicationEvent</code> 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下：</p>
<pre><code class="language-java">/**
 * 使用ApplicationListener来初始化一些数据到application域中的监听器
 * @author shengni ni
 * @date 2018/07/05
 */
@Component
public class MyServletContextListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; {

    @Override
    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
        // 先获取到application上下文
        ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();
        // 获取对应的service
        UserService userService = applicationContext.getBean(UserService.class);
        User user = userService.getUser();
        // 获取application域对象，将查到的信息放到application域中
        ServletContext application = applicationContext.getBean(ServletContext.class);
        application.setAttribute(&quot;user&quot;, user);
    }
}
</code></pre>
<p>正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/listener&quot;)
public class TestController {

    @GetMapping(&quot;/user&quot;)
    public User getUser(HttpServletRequest request) {
        ServletContext application = request.getServletContext();
        return (User) application.getAttribute(&quot;user&quot;);
    }
}
</code></pre>
<p>启动项目，在浏览器中输入 <code>http://localhost:8080/listener/user</code> 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。</p>
<h3 id="22-监听http会话-session对象">2.2 监听HTTP会话 Session对象</h3>
<p>监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。</p>
<pre><code class="language-java">/**
 * 使用HttpSessionListener统计在线用户数的监听器
 * @author shengwu ni
 * @date 2018/07/05
 */
@Component
public class MyHttpSessionListener implements HttpSessionListener {

    private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class);

    /**
     * 记录在线的用户数量
     */
    public Integer count = 0;

    @Override
    public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) {
        logger.info(&quot;新用户上线了&quot;);
        count++;
        httpSessionEvent.getSession().getServletContext().setAttribute(&quot;count&quot;, count);
    }

    @Override
    public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) {
        logger.info(&quot;用户下线了&quot;);
        count--;
        httpSessionEvent.getSession().getServletContext().setAttribute(&quot;count&quot;, count);
    }
}
</code></pre>
<p>可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 <code>sessionCreated</code> 和 <code>sessionDestroyed</code> 方法，在 <code>sessionCreated</code> 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，<code>sessionDestroyed</code> 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/listener&quot;)
public class TestController {

    /**
     * 获取当前在线人数，该方法有bug
     * @param request
     * @return
     */
    @GetMapping(&quot;/total&quot;)
    public String getTotalUser(HttpServletRequest request) {
        Integer count = (Integer) request.getSession().getServletContext().getAttribute(&quot;count&quot;);
        return &quot;当前在线人数：&quot; + count;
    }
}
</code></pre>
<p>该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 <code>localhost:8080/listener/total</code> 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下：</p>
<pre><code class="language-java">@GetMapping(&quot;/total2&quot;)
public String getTotalUser(HttpServletRequest request, HttpServletResponse response) {
    Cookie cookie;
    try {
        // 把sessionId记录在浏览器中
        cookie = new Cookie(&quot;JSESSIONID&quot;, URLEncoder.encode(request.getSession().getId(), &quot;utf-8&quot;));
        cookie.setPath(&quot;/&quot;);
        //设置cookie有效期为2天，设置长一点
        cookie.setMaxAge( 48*60 * 60);
        response.addCookie(cookie);
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
    Integer count = (Integer) request.getSession().getServletContext().getAttribute(&quot;count&quot;);
    return &quot;当前在线人数：&quot; + count;
}
</code></pre>
<p>可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。</p>
<h3 id="23-监听客户端请求servlet-request对象">2.3 监听客户端请求Servlet Request对象</h3>
<p>使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下：</p>
<pre><code class="language-java">/**
 * 使用ServletRequestListener获取访问信息
 * @author shengwu ni
 * @date 2018/07/05
 */
@Component
public class MyServletRequestListener implements ServletRequestListener {

    private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class);

    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();
        logger.info(&quot;session id为：{}&quot;, request.getRequestedSessionId());
        logger.info(&quot;request url为：{}&quot;, request.getRequestURL());

        request.setAttribute(&quot;name&quot;, &quot;倪升武&quot;);
    }

    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {

        logger.info(&quot;request end&quot;);
        HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest();
        logger.info(&quot;request域中保存的name值为：{}&quot;, request.getAttribute(&quot;name&quot;));

    }

}
</code></pre>
<p>这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。</p>
<pre><code class="language-java">@GetMapping(&quot;/request&quot;)
public String getRequestInfo(HttpServletRequest request) {
    System.out.println(&quot;requestListener中的初始化的name数据：&quot; + request.getAttribute(&quot;name&quot;));
    return &quot;success&quot;;
}
</code></pre>
<h2 id="3-spring-boot中自定义事件监听">3. Spring Boot中自定义事件监听</h2>
<p>在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。</p>
<h3 id="31-自定义事件">3.1 自定义事件</h3>
<p>自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下：</p>
<pre><code class="language-java">/**
 * 自定义事件
 * @author shengwu ni
 * @date 2018/07/05
 */
public class MyEvent extends ApplicationEvent {

    private User user;

    public MyEvent(Object source, User user) {
        super(source);
        this.user = user;
    }

    // 省去get、set方法
}
</code></pre>
<h3 id="32-自定义监听器">3.2 自定义监听器</h3>
<p>接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 <code>ApplicationListener</code> 接口即可。如下：</p>
<pre><code class="language-java">/**
 * 自定义监听器，监听MyEvent事件
 * @author shengwu ni
 * @date 2018/07/05
 */
@Component
public class MyEventListener implements ApplicationListener&lt;MyEvent&gt; {
    @Override
    public void onApplicationEvent(MyEvent myEvent) {
        // 把事件中的信息获取到
        User user = myEvent.getUser();
        // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等
        System.out.println(&quot;用户名：&quot; + user.getUsername());
        System.out.println(&quot;密码：&quot; + user.getPassword());

    }
}
</code></pre>
<p>然后重写 <code>onApplicationEvent</code> 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。</p>
<p>OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下：</p>
<pre><code class="language-java">/**
 * UserService
 * @author shengwu ni
 */
@Service
public class UserService {

    @Resource
    private ApplicationContext applicationContext;

    /**
     * 发布事件
     * @return
     */
    public User getUser2() {
        User user = new User(1L, &quot;倪升武&quot;, &quot;123456&quot;);
        // 发布事件
        MyEvent event = new MyEvent(this, user);
        applicationContext.publishEvent(event);
        return user;
    }
}
</code></pre>
<p>在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。</p>
<p>最后，在 Controller 中写一个接口来测试一下：</p>
<pre><code class="language-java">@GetMapping(&quot;/request&quot;)
public String getRequestInfo(HttpServletRequest request) {
    System.out.println(&quot;requestListener中的初始化的name数据：&quot; + request.getAttribute(&quot;name&quot;));
    return &quot;success&quot;;
}
</code></pre>
<p>在浏览器中输入 <code>http://localhost:8080/listener/publish</code>，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。</p>
<h2 id="4-总结-6">4. 总结</h2>
<p>本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="使用拦截器"></a></p>
<h1 id="spring-boot中使用拦截器">Spring Boot中使用拦截器</h1>
<p>拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。</p>
<h2 id="1-拦截器的快速使用">1. 拦截器的快速使用</h2>
<p>使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。</p>
<h3 id="11-定义拦截器">1.1 定义拦截器</h3>
<p>定义拦截器，只需要实现 <code>HandlerInterceptor</code> 接口，<code>HandlerInterceptor</code> 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： <code>preHandle(……)</code>、<code>postHandle(……)</code> 和 <code>afterCompletion(……)</code> 。</p>
<blockquote>
<p><code>preHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 <code>preHandle(……)</code> 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。<br>
<code>postHandle(……)</code> 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。<br>
<code>afterCompletion(……)</code> 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 <code>preHandle(……)</code> 被成功执行后并且返回 true 才会被执行。</p>
</blockquote>
<p>了解了该接口，接下来自定义一个拦截器。</p>
<pre><code class="language-java">/**
 * 自定义拦截器
 * @author shengwu ni
 * @date 2018/08/03
 */
public class MyInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        String methodName = method.getName();
        logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);
        // 返回true才会继续执行，返回false则取消当前请求
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.info(&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.info(&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;);
    }
}
</code></pre>
<p>OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。</p>
<h3 id="12-配置拦截器">1.2 配置拦截器</h3>
<p>在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 <code>addInterceptors</code> 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下：</p>
<pre><code class="language-java">@Configuration
public class MyInterceptorConfig extends WebMvcConfigurationSupport {

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);
        super.addInterceptors(registry);
    }
}
</code></pre>
<p>在该配置中重写 <code>addInterceptors</code> 方法，将我们上面自定义的拦截器添加进去，<code>addPathPatterns</code> 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/interceptor&quot;)
public class InterceptorController {

    @RequestMapping(&quot;/test&quot;)
    public String test() {
        return &quot;hello&quot;;
    }
}
</code></pre>
<p>让其跳转到 hello.html 页面，直接在 hello.html 中输出 <code>hello interceptor</code> 即可。启动项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 看一下控制台的日志：</p>
<pre><code>====拦截到了方法：test，在该方法执行之前执行====  
执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染  
整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了
</code></pre>
<p>可以看出拦截器已经生效，并能看出其执行顺序。</p>
<h3 id="13-解决静态资源被拦截问题">1.3 解决静态资源被拦截问题</h3>
<p>上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。</p>
<p>也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。</p>
<p>如何放开呢？除了在 MyInterceptorConfig 配置类中重写 <code>addInterceptors</code> 方法外，还需要再重写一个方法：<code>addResourceHandlers</code>，将静态资源放开：</p>
<pre><code class="language-java">/**
 * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问
 * @param registry
 */
@Override
protected void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler(&quot;/**&quot;).addResourceLocations(&quot;classpath:/static/&quot;);
    super.addResourceHandlers(registry);
}
</code></pre>
<p>这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。</p>
<p>我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 <code>addInterceptors</code> 方法，将自定义的拦截器添加进去即可，如下：</p>
<pre><code class="language-java">@Configuration
public class MyInterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 实现WebMvcConfigurer不会导致静态资源被拦截
        registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/**&quot;);
    }
}
</code></pre>
<p>这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。</p>
<p>这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。</p>
<h2 id="2-拦截器使用实例">2. 拦截器使用实例</h2>
<h3 id="21-判断用户有没有登录">2.1 判断用户有没有登录</h3>
<p>一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 <code>preHandle</code> 方法，如下：</p>
<pre><code class="language-java">@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

    HandlerMethod handlerMethod = (HandlerMethod) handler;
    Method method = handlerMethod.getMethod();
    String methodName = method.getName();
    logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);

    // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token
    String token = request.getParameter(&quot;token&quot;);
    if (null == token || &quot;&quot;.equals(token)) {
        logger.info(&quot;用户未登录，没有权限执行……请登录&quot;);
        return false;
    }

    // 返回true才会继续执行，返回false则取消当前请求
    return true;
}
</code></pre>
<p>重启项目，在浏览器中输入 <code>localhost:8080/interceptor/test</code> 后查看控制台日志，发现被拦截，如果在浏览器中输入 <code>localhost:8080/interceptor/test?token=123</code> 即可正常往下走。</p>
<h3 id="22-取消拦截操作">2.2 取消拦截操作</h3>
<p>根据上文，如果我要拦截所有 <code>/admin</code> 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 <code>/admin</code> 开头的，但是不能拦截，比如 <code>/admin/login</code> 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？</p>
<p>是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解：</p>
<pre><code class="language-java">/**
 * 该注解用来指定某个方法不用拦截
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UnInterception {
}
</code></pre>
<p>然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下：</p>
<pre><code class="language-java">@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

    HandlerMethod handlerMethod = (HandlerMethod) handler;
    Method method = handlerMethod.getMethod();
    String methodName = method.getName();
    logger.info(&quot;====拦截到了方法：{}，在该方法执行之前执行====&quot;, methodName);

    // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截
    // @UnInterception 是我们自定义的注解
    UnInterception unInterception = method.getAnnotation(UnInterception.class);
    if (null != unInterception) {
        return true;
    }
    // 返回true才会继续执行，返回false则取消当前请求
    return true;
}
</code></pre>
<p>Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 <code>http://localhost:8080/interceptor/test2?token=123</code> 测试一下，可以看出，加了该注解的方法不会被拦截。</p>
<h2 id="3-总结-2">3. 总结</h2>
<p>本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成Redis"></a></p>
<h1 id="spring-boot-中集成redis">Spring Boot 中集成Redis</h1>
<h2 id="1-redis-介绍">1. Redis 介绍</h2>
<p>Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。<br>
NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。<br>
Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图：</p>
<figure data-type="image" tabindex="16"><img src="https://images.gitbook.cn/4258b9c0-9f93-11e8-a34f-d93da92347ea" alt="Redis使用场景" loading="lazy"></figure>
<p>Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。</p>
<h2 id="2-redis-安装">2. Redis 安装</h2>
<p>本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程：</p>
<ul>
<li>安装 gcc 编译</li>
</ul>
<p>因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc：</p>
<pre><code>yum install gcc-c++
</code></pre>
<ul>
<li>下载 redis</li>
</ul>
<p>有两种方式下载安装包，一种是去官网上下载（https://redis.io），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载：</p>
<pre><code>wget http://download.redis.io/releases/redis-3.2.8.tar.gz
</code></pre>
<p>如果没有安装过 wget，可以通过如下命令安装：</p>
<pre><code>yum install wget
</code></pre>
<ul>
<li>解压安装</li>
</ul>
<p>解压安装包：</p>
<pre><code>tar –vzxf redis-3.2.8.tar.gz
</code></pre>
<p>然后将解压的文件夹 redis-3.2.8 放到 <code>/usr/local/</code> 下，一般安装软件都放在 <code>/usr/local</code> 下。然后进入 <code>/usr/local/redis-3.2.8/</code> 文件夹下，执行 <code>make</code> 命令即可完成安装。<br>
【注】如果 make 失败，可以尝试如下命令：</p>
<pre><code>make MALLOC=libc
make install
</code></pre>
<ul>
<li>修改配置文件</li>
</ul>
<p>安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。<br>
打开 redis 配置文件：<code>vi redis.conf</code><br>
在命令模式下输入 <code>/bind</code> 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即：</p>
<pre><code>bind 0.0.0.0
</code></pre>
<p>使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。<br>
将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。</p>
<ul>
<li>启动 redis</li>
</ul>
<p>在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis：</p>
<pre><code>redis-server ./redis.conf
</code></pre>
<p>再启动 redis 客户端：</p>
<pre><code>redis-cli
</code></pre>
<p>由于我们设置了密码，在启动客户端之后，输入 <code>auth 123456</code> 即可登录进入客户端。<br>
然后我们来测试一下，往 redis 中插入一个数据：</p>
<pre><code>set name CSDN
</code></pre>
<p>然后来获取 name</p>
<pre><code>get name
</code></pre>
<p>如果正常获取到 CSDN，则说明没有问题。</p>
<h2 id="3-spring-boot-集成-redis">3. Spring Boot 集成 Redis</h2>
<h3 id="31-依赖导入">3.1 依赖导入</h3>
<p>Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--阿里巴巴fastjson --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.35&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。</p>
<h3 id="32-redis-配置">3.2 Redis 配置</h3>
<p>导入了依赖之后，我们在 application.yml 文件里配置 redis：</p>
<pre><code class="language-yml">server:
  port: 8080
spring:
  #redis相关配置
  redis:
    database: 5
    # 配置redis的主机地址，需要修改成自己的
    host: 192.168.48.190
    port: 6379
    password: 123456
    timeout: 5000
    jedis:
      pool:
        # 连接池中的最大空闲连接，默认值也是8。
        max-idle: 500
        # 连接池中的最小空闲连接，默认值也是0。
        min-idle: 50
        # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)
        max-active: 1000
        # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException
        max-wait: 2000
</code></pre>
<h3 id="33-常用-api-介绍">3.3 常用 api 介绍</h3>
<p>Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。</p>
<p>有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。</p>
<h4 id="331-redisstring-类型">3.3.1 redis:string 类型</h4>
<p>新建一个 RedisService，注入 StringRedisTemplate，使用 <code>stringRedisTemplate.opsForValue()</code> 可以获取 <code>ValueOperations&lt;String, String&gt;</code> 对象，通过该对象即可读写 redis 数据库了。如下：</p>
<pre><code class="language-java">public class RedisService {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * set redis: string类型
     * @param key key
     * @param value value
     */
    public void setString(String key, String value){
        ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue();
        valueOperations.set(key, value);
    }

    /**
     * get redis: string类型
     * @param key key
     * @return
     */
    public String getString(String key){
        return stringRedisTemplate.opsForValue().get(key);
    }
</code></pre>
<p>该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class Course14ApplicationTests {

    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);

	@Resource
	private RedisService redisService;

	@Test
	public void contextLoads() {
        //测试redis的string类型
        redisService.setString(&quot;weichat&quot;,&quot;程序员私房菜&quot;);
        logger.info(&quot;我的微信公众号为：{}&quot;, redisService.getString(&quot;weichat&quot;));

        // 如果是个实体，我们可以使用json工具转成json字符串，
        User user = new User(&quot;CSDN&quot;, &quot;123456&quot;);
        redisService.setString(&quot;userInfo&quot;, JSON.toJSONString(user));
        logger.info(&quot;用户信息：{}&quot;, redisService.getString(&quot;userInfo&quot;));
    }
}
</code></pre>
<p>先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下：</p>
<pre><code>我的微信公众号为：程序员私房菜
用户信息：{&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;}
</code></pre>
<h4 id="332-redishash-类型">3.3.2 redis:hash 类型</h4>
<p>hash 类型其实原理和 string 一样的，但是有两个 key，使用 <code>stringRedisTemplate.opsForHash()</code> 可以获取 <code>HashOperations&lt;String, Object, Object&gt;</code> 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。</p>
<pre><code class="language-java">@Service
public class RedisService {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * set redis: hash类型
     * @param key key
     * @param filedKey filedkey
     * @param value value
     */
    public void setHash(String key, String filedKey, String value){
        HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash();
        hashOperations.put(key,filedKey, value);
    }

    /**
     * get redis: hash类型
     * @param key key
     * @param filedkey filedkey
     * @return
     */
    public String getHash(String key, String filedkey){
        return (String) stringRedisTemplate.opsForHash().get(key, filedkey);
    }
}
</code></pre>
<p>可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下：</p>
<pre><code class="language-java">@SpringBootTest
public class Course14ApplicationTests {

    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);

	@Resource
	private RedisService redisService;

	@Test
	public void contextLoads() {
        //测试redis的hash类型
        redisService.setHash(&quot;user&quot;, &quot;name&quot;, JSON.toJSONString(user));
        logger.info(&quot;用户姓名：{}&quot;, redisService.getHash(&quot;user&quot;,&quot;name&quot;));
    }
}
</code></pre>
<h4 id="333-redislist-类型">3.3.3 redis:list 类型</h4>
<p>使用 <code>stringRedisTemplate.opsForList()</code> 可以获取 <code>ListOperations&lt;String, String&gt; listOperations</code>  redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。</p>
<pre><code class="language-java">@Service
public class RedisService {

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    /**
     * set redis:list类型
     * @param key key
     * @param value value
     * @return
     */
    public long setList(String key, String value){
        ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList();
        return listOperations.leftPush(key, value);
    }

    /**
     * get redis:list类型
     * @param key key
     * @param start start
     * @param end end
     * @return
     */
    public List&lt;String&gt; getList(String key, long start, long end){
        return stringRedisTemplate.opsForList().range(key, start, end);
    }
}
</code></pre>
<p>可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class Course14ApplicationTests {

    private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class);

	@Resource
	private RedisService redisService;

	@Test
	public void contextLoads() {
        //测试redis的list类型
        redisService.setList(&quot;list&quot;, &quot;football&quot;);
        redisService.setList(&quot;list&quot;, &quot;basketball&quot;);
        List&lt;String&gt; valList = redisService.getList(&quot;list&quot;,0,-1);
        for(String value :valList){
            logger.info(&quot;list中有：{}&quot;, value);
        }
    }
}
</code></pre>
<h2 id="4-总结-7">4. 总结</h2>
<p>本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成ActiveMQ"></a></p>
<h1 id="spring-boot中集成activemq">Spring Boot中集成ActiveMQ</h1>
<h2 id="1-jms-和-activemq-介绍">1. JMS 和 ActiveMQ 介绍</h2>
<h3 id="11-jms-是啥">1.1 JMS 是啥</h3>
<p>百度百科的解释：</p>
<blockquote>
<p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>
</blockquote>
<p>JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型：</p>
<blockquote>
<p>连接工厂：ConnectionFactory<br>
JMS连接：Connection<br>
JMS会话：Session<br>
JMS目的：Destination<br>
JMS生产者：Producer<br>
JMS消费者：Consumer<br>
JMS消息两种类型：点对点和发布/订阅。</p>
</blockquote>
<p>可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。</p>
<h3 id="12-activemq">1.2 ActiveMQ</h3>
<p>ActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。</p>
<p>异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。</p>
<h2 id="2-activemq安装">2. ActiveMQ安装</h2>
<p>使用 ActiveMQ 首先需要去官网下载，官网地址为：http://activemq.apache.org/<br>
本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 <code>activemq-all-5.15.3.jar</code>，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。</p>
<p>在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。<br>
消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费<br>
启动完成后，在浏览器中输入 <code>http://127.0.0.1:8161/admin/</code> 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下：</p>
<figure data-type="image" tabindex="17"><img src="https://images.gitbook.cn/cfb9c460-aa94-11e8-888f-df33be8ed191" alt="activemq" loading="lazy"></figure>
<p>我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？</p>
<p>点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。</p>
<p>发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。</p>
<h2 id="3-activemq集成">3. ActiveMQ集成</h2>
<h3 id="31-依赖导入和配置">3.1 依赖导入和配置</h3>
<p>在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后在 application.yml 配置文件中，对 activemq 做一下配置：</p>
<pre><code class="language-yml">spring:
  activemq:
  	# activemq url
    broker-url: tcp://localhost:61616
    in-memory: true
    pool:
      # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate
      enabled: false
</code></pre>
<h3 id="32-queue-和-topic-的创建">3.2 Queue 和 Topic 的创建</h3>
<p>首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下：</p>
<pre><code class="language-java">/**
 * activemq的配置
 * @author  shengwu ni
 */
@Configuration
public class ActiveMqConfig {
    /**
     * 发布/订阅模式队列名称
     */
    public static final String TOPIC_NAME = &quot;activemq.topic&quot;;
    /**
     * 点对点模式队列名称
     */
    public static final String QUEUE_NAME = &quot;activemq.queue&quot;;

    @Bean
    public Destination topic() {
        return new ActiveMQTopic(TOPIC_NAME);
    }

    @Bean
    public Destination queue() {
        return new ActiveMQQueue(QUEUE_NAME);
    }
}
</code></pre>
<p>可以看出创建 Queue 和 Topic 两种消息，分别使用 <code>new ActiveMQQueue</code> 和 <code>new ActiveMQTopic</code> 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。</p>
<h3 id="33-消息的发送接口">3.3 消息的发送接口</h3>
<p>在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下：</p>
<pre><code class="language-java">/**
 * 消息发送者
 * @author shengwu ni
 */
@Service
public class MsgProducer {

    @Resource
    private JmsMessagingTemplate jmsMessagingTemplate;

    public void sendMessage(Destination destination, String msg) {
        jmsMessagingTemplate.convertAndSend(destination, msg);
    }
}
</code></pre>
<p><code>convertAndSend</code> 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。</p>
<h3 id="34-点对点消息生产与消费">3.4 点对点消息生产与消费</h3>
<h4 id="341-点对点消息的生产">3.4.1 点对点消息的生产</h4>
<p>消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 <code>sendMessage</code> 即可成功生产一条消息。</p>
<pre><code class="language-java">/**
 * ActiveMQ controller
 * @author shengwu ni
 */
@RestController
@RequestMapping(&quot;/activemq&quot;)
public class ActiveMqController {

    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);

    @Resource
    private MsgProducer producer;
    @Resource
    private Destination queue;

    @GetMapping(&quot;/send/queue&quot;)
    public String sendQueueMessage() {

        logger.info(&quot;===开始发送点对点消息===&quot;);
        producer.sendMessage(queue, &quot;Queue: hello activemq!&quot;);
        return &quot;success&quot;;
    }
}
</code></pre>
<h4 id="342-点对点消息的消费">3.4.2 点对点消息的消费</h4>
<p>点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。</p>
<pre><code class="language-java">/**
 * 消息消费者
 * @author shengwu ni
 */
@Service
public class QueueConsumer {

    /**
     * 接收点对点消息
     * @param msg
     */
    @JmsListener(destination = ActiveMqConfig.QUEUE_NAME)
    public void receiveQueueMsg(String msg) {
        System.out.println(&quot;收到的消息为：&quot; + msg);
    }
}
</code></pre>
<p>可以看出，使用 <code>@JmsListener</code> 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。</p>
<h4 id="343-测试一下">3.4.3 测试一下</h4>
<p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/queue</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p>
<pre><code>收到的消息为：Queue: hello activemq!
</code></pre>
<h3 id="35-发布订阅消息的生产和消费">3.5 发布/订阅消息的生产和消费</h3>
<h4 id="351-发布订阅消息的生产">3.5.1 发布/订阅消息的生产</h4>
<p>和点对点消息一样，我们注入 topic 并调用 producer 的 <code>sendMessage</code> 方法即可发送订阅消息，如下，不再赘述：</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/activemq&quot;)
public class ActiveMqController {

    private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class);

    @Resource
    private MsgProducer producer;
    @Resource
    private Destination topic;

    @GetMapping(&quot;/send/topic&quot;)
    public String sendTopicMessage() {

        logger.info(&quot;===开始发送订阅消息===&quot;);
        producer.sendMessage(topic, &quot;Topic: hello activemq!&quot;);
        return &quot;success&quot;;
    }
}
</code></pre>
<h4 id="352-发布订阅消息的消费">3.5.2 发布/订阅消息的消费</h4>
<p>发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置：</p>
<pre><code class="language-yml">spring:
  jms:
    pub-sub-domain: true
</code></pre>
<p>该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。</p>
<p>比较好的解决办法是，我们定义一个工厂，<code>@JmsListener</code> 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加：</p>
<pre><code class="language-java">/**
 * activemq的配置
 *
 * @author shengwu ni
 */
@Configuration
public class ActiveMqConfig {
    // 省略其他内容

    /**
     * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory
     */
    @Bean
    public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true
        factory.setPubSubDomain(true);
        return factory;
    }
}
</code></pre>
<p>经过这样的配置之后，我们在消费的时候，在 <code>@JmsListener</code> 注解中指定这个容器工厂即可消费 topic 消息。如下：</p>
<pre><code class="language-java">/**
 * Topic消息消费者
 * @author shengwu ni
 */
@Service
public class TopicConsumer1 {

    /**
     * 接收订阅消息
     * @param msg
     */
    @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = &quot;topicListenerContainer&quot;)
    public void receiveTopicMsg(String msg) {
        System.out.println(&quot;收到的消息为：&quot; + msg);
    }

}
</code></pre>
<p>指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。</p>
<h4 id="353-测试一下">3.5.3 测试一下</h4>
<p>启动项目，在浏览器中输入：<code>http://localhost:8081/activemq/send/topic</code>，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。</p>
<pre><code>收到的消息为：Topic: hello activemq!
收到的消息为：Topic: hello activemq!
</code></pre>
<h2 id="4-总结-8">4. 总结</h2>
<p>本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成Shiro"></a></p>
<h1 id="spring-boot中集成-shiro">Spring Boot中集成 Shiro</h1>
<p>Shiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。</p>
<h2 id="1-shiro-三大核心组件">1. Shiro 三大核心组件</h2>
<p>Shiro 有三大核心的组件：<code>Subject</code>、<code>SecurityManager</code> 和 <code>Realm</code>。先来看一下它们之间的关系。</p>
<figure data-type="image" tabindex="18"><img src="https://images.gitbook.cn/2dd0f5f0-af4a-11e8-a51c-93c39f2785b1" alt="三大核心组件的关系" loading="lazy"></figure>
<ol>
<li>Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。</li>
</ol>
<blockquote>
<p>Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；<br>
Credentials：凭证。常见有密码，数字证书等等。</p>
</blockquote>
<p>说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。</p>
<ol start="2">
<li>
<p>SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。</p>
</li>
<li>
<p>Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。</p>
</li>
</ol>
<h2 id="1-shiro-身份和权限认证">1. Shiro 身份和权限认证</h2>
<h3 id="12-shiro-身份认证">1.2 Shiro 身份认证</h3>
<p>我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图：</p>
<figure data-type="image" tabindex="19"><img src="https://images.gitbook.cn/f21c53a0-af4f-11e8-a51c-93c39f2785b1" alt="认证过程" loading="lazy"></figure>
<p>Step1：应用程序代码在调用 <code>Subject.login(token)</code> 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。</p>
<p>Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。</p>
<p>Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。</p>
<h3 id="13-shiro-权限认证">1.3 Shiro 权限认证</h3>
<p>权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。</p>
<blockquote>
<p>权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；<br>
角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；<br>
用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。</p>
</blockquote>
<p>它们之间的的关系可以用下图来表示：</p>
<figure data-type="image" tabindex="20"><img src="https://images.gitbook.cn/44a68bc0-af75-11e8-85ef-dd986da3511e" alt="用户、角色和权限的关系" loading="lazy"></figure>
<p>一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。</p>
<h2 id="2-spring-boot-集成-shiro-过程">2. Spring Boot 集成 Shiro 过程</h2>
<h3 id="21-依赖导入-3">2.1 依赖导入</h3>
<p>Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.4.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="22-数据库表数据初始化">2.2 数据库表数据初始化</h3>
<p>这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。</p>
<pre><code class="language-sql">CREATE TABLE `t_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `rolename` varchar(20) DEFAULT NULL COMMENT '角色名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8

CREATE TABLE `t_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键',
  `username` varchar(20) NOT NULL COMMENT '用户名',
  `password` varchar(20) NOT NULL COMMENT '密码',
  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role表',
  PRIMARY KEY (`id`),
  KEY `role_id` (`role_id`),
  CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8

CREATE TABLE `t_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `permissionname` varchar(50) NOT NULL COMMENT '权限名',
  `role_id` int(11) DEFAULT NULL COMMENT '外键关联role',
  PRIMARY KEY (`id`),
  KEY `role_id` (`role_id`),
  CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8
</code></pre>
<p>其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。<br>
t_user 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">username</th>
<th style="text-align:center">password</th>
<th style="text-align:center">role_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">csdn1</td>
<td style="text-align:center">123456</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">csdn2</td>
<td style="text-align:center">123456</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">csdn3</td>
<td style="text-align:center">123456</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>t_role 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">rolename</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">admin</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">teacher</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">student</td>
</tr>
</tbody>
</table>
<p>t_permission 表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">permissionname</th>
<th style="text-align:center">role_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>user:*</code></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>student:*</code></td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>解释一下这里的权限：<code>user:*</code>表示权限可以是 <code>user:create</code> 或者其他，<code>*</code> 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。</p>
<h3 id="22-自定义-realm">2.2 自定义 Realm</h3>
<p>有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法：</p>
<blockquote>
<p><code>doGetAuthenticationInfo()</code> 方法：用来验证当前登录的用户，获取认证信息<br>
<code>doGetAuthorizationInfo()</code> 方法：用来为当前登陆成功的用户授予权限和角色</p>
</blockquote>
<p>具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观：</p>
<pre><code class="language-java">/**
 * 自定义realm
 * @author shengwu ni
 */
public class MyRealm extends AuthorizingRealm {

    @Resource
    private UserService userService;

    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        // 获取用户名
        String username = (String) principalCollection.getPrimaryPrincipal();
        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
        // 给该用户设置角色，角色信息存在t_role表中取
        authorizationInfo.setRoles(userService.getRoles(username));
        // 给该用户设置权限，权限信息存在t_permission表中取
        authorizationInfo.setStringPermissions(userService.getPermissions(username));
        return authorizationInfo;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释
        String username = (String) authenticationToken.getPrincipal();
        // 根据用户名从数据库中查询该用户
        User user = userService.getByUsername(username);
        if(user != null) {
            // 把当前用户存到session中
            SecurityUtils.getSubject().getSession().setAttribute(&quot;user&quot;, user);
            // 传入用户名和密码进行身份认证，并返回认证信息
            AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), &quot;myRealm&quot;);
            return authcInfo;
        } else {
            return null;
        }
    }
}
</code></pre>
<p>从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。</p>
<h3 id="23-shiro-配置">2.3 Shiro 配置</h3>
<p>自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下：</p>
<p>配置自定义 realm：</p>
<pre><code class="language-java">@Configuration
public class ShiroConfig {

    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);

    /**
     * 注入自定义的realm
     * @return MyRealm
     */
    @Bean
    public MyRealm myAuthRealm() {
        MyRealm myRealm = new MyRealm();
        logger.info(&quot;====myRealm注册完成=====&quot;);
        return myRealm;
    }
}
</code></pre>
<p>配置安全管理器 SecurityManager：</p>
<pre><code class="language-java">@Configuration
public class ShiroConfig {

    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);

    /**
     * 注入安全管理器
     * @return SecurityManager
     */
    @Bean
    public SecurityManager securityManager() {
        // 将自定义realm加进来
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm());
        logger.info(&quot;====securityManager注册完成====&quot;);
        return securityManager;
    }
}
</code></pre>
<p>配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。</p>
<p>配置 Shiro 过滤器：</p>
<pre><code class="language-java">@Configuration
public class ShiroConfig {

    private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class);
    
    /**
     * 注入Shiro过滤器
     * @param securityManager 安全管理器
     * @return ShiroFilterFactoryBean
     */
    @Bean
    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {
        // 定义shiroFactoryBean
        ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean();

        // 设置自定义的securityManager
        shiroFilterFactoryBean.setSecurityManager(securityManager);

        // 设置默认登录的url，身份认证失败会访问该url
        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);
        // 设置成功之后要跳转的链接
        shiroFilterFactoryBean.setSuccessUrl(&quot;/success&quot;);
        // 设置未授权界面，权限认证失败会访问该url
        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);

        // LinkedHashMap是有序的，进行顺序拦截器配置
        Map&lt;String,String&gt; filterChainMap = new LinkedHashMap&lt;&gt;();

        // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行
        filterChainMap.put(&quot;/css/**&quot;, &quot;anon&quot;);
        filterChainMap.put(&quot;/imgs/**&quot;, &quot;anon&quot;);
        filterChainMap.put(&quot;/js/**&quot;, &quot;anon&quot;);
        filterChainMap.put(&quot;/swagger-*/**&quot;, &quot;anon&quot;);
        filterChainMap.put(&quot;/swagger-ui.html/**&quot;, &quot;anon&quot;);
        // 登录url 放行
        filterChainMap.put(&quot;/login&quot;, &quot;anon&quot;);

        // “/user/admin” 开头的需要身份认证，authc表示要身份认证
        filterChainMap.put(&quot;/user/admin*&quot;, &quot;authc&quot;);
        // “/user/student” 开头的需要角色认证，是“admin”才允许
        filterChainMap.put(&quot;/user/student*/**&quot;, &quot;roles[admin]&quot;);
        // “/user/teacher” 开头的需要权限认证，是“user:create”才允许
        filterChainMap.put(&quot;/user/teacher*/**&quot;, &quot;perms[\&quot;user:create\&quot;]&quot;);

        // 配置logout过滤器
        filterChainMap.put(&quot;/logout&quot;, &quot;logout&quot;);

        // 设置shiroFilterFactoryBean的FilterChainDefinitionMap
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap);
        logger.info(&quot;====shiroFilterFactoryBean注册完成====&quot;);
        return shiroFilterFactoryBean;
    }
}
</code></pre>
<p>配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有：</p>
<blockquote>
<p>默认登录的 url：身份认证失败会访问该 url<br>
认证成功之后要跳转的 url<br>
权限认证失败会访问该 url<br>
需要拦截或者放行的 url：这些都放在一个 map 中</p>
</blockquote>
<p>从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Filter</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">anon</td>
<td style="text-align:center">开放权限，可以理解为匿名用户或游客，可以直接访问的</td>
</tr>
<tr>
<td style="text-align:center">authc</td>
<td style="text-align:center">需要身份认证的</td>
</tr>
<tr>
<td style="text-align:center">logout</td>
<td style="text-align:center">注销，执行后会直接跳转到 <code>shiroFilterFactoryBean.setLoginUrl();</code> 设置的 url，即登录页面</td>
</tr>
<tr>
<td style="text-align:center">roles[admin]</td>
<td style="text-align:center">参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[&quot;admin，user&quot;]，当有多个参数时必须每个参数都通过才算通过</td>
</tr>
<tr>
<td style="text-align:center">perms[user]</td>
<td style="text-align:center">参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过</td>
</tr>
</tbody>
</table>
<h3 id="24-使用-shiro-进行认证">2.4 使用 Shiro 进行认证</h3>
<p>到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口：</p>
<blockquote>
<p>接口一： 使用 <code>http://localhost:8080/user/admin</code> 来验证身份认证<br>
接口二： 使用 <code>http://localhost:8080/user/student</code> 来验证角色认证<br>
接口三： 使用 <code>http://localhost:8080/user/teacher</code> 来验证权限认证<br>
接口四： 使用 <code>http://localhost:8080/user/login</code> 来实现用户登录</p>
</blockquote>
<p>然后来一下认证的流程：</p>
<blockquote>
<p>流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。<br>
流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。<br>
流程三： 访问接口二，测试角色认证是否成功。<br>
流程四： 访问接口三，测试权限认证是否成功。</p>
</blockquote>
<h4 id="241-身份-角色-权限认证接口">2.4.1 身份、角色、权限认证接口</h4>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    /**
     * 身份认证测试接口
     * @param request
     * @return
     */
    @RequestMapping(&quot;/admin&quot;)
    public String admin(HttpServletRequest request) {
        Object user = request.getSession().getAttribute(&quot;user&quot;);
        return &quot;success&quot;;
    }

    /**
     * 角色认证测试接口
     * @param request
     * @return
     */
    @RequestMapping(&quot;/student&quot;)
    public String student(HttpServletRequest request) {
        return &quot;success&quot;;
    }

    /**
     * 权限认证测试接口
     * @param request
     * @return
     */
    @RequestMapping(&quot;/teacher&quot;)
    public String teacher(HttpServletRequest request) {
        return &quot;success&quot;;
    }
}
</code></pre>
<p>这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。</p>
<h4 id="242-用户登录接口">2.4.2 用户登录接口</h4>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {

    /**
     * 用户登录接口
     * @param user user
     * @param request request
     * @return string
     */
    @PostMapping(&quot;/login&quot;)
    public String login(User user, HttpServletRequest request) {

        // 根据用户名和密码创建token
        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword());
        // 获取subject认证主体
        Subject subject = SecurityUtils.getSubject();
        try{
            // 开始认证，这一步会跳到我们自定义的realm中
            subject.login(token);
            request.getSession().setAttribute(&quot;user&quot;, user);
            return &quot;success&quot;;
        }catch(Exception e){
            e.printStackTrace();
            request.getSession().setAttribute(&quot;user&quot;, user);
            request.setAttribute(&quot;error&quot;, &quot;用户名或密码错误！&quot;);
            return &quot;login&quot;;
        }
    }
}
</code></pre>
<p>我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 <code>subject.login(token)</code> 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 <code>doGetAuthenticationInfo</code> 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。</p>
<h4 id="243-测试一下">2.4.3 测试一下</h4>
<p>最后，启动项目，测试一下：<br>
浏览器请求 <code>http://localhost:8080/user/admin</code> 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 <code>/login</code> 接口，然后跳转到 <code>login.html</code> 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 <code>http://localhost:8080/user/student</code> 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 <code>http://localhost:8080/user/teacher</code> 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 <code>user:*</code>，满足配置中的 <code>user:create</code>，所以认证通过。</p>
<p>接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。</p>
<h2 id="3-总结-3">3. 总结</h2>
<p>本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="集成Lucence"></a></p>
<h1 id="spring-boot中集成lucence">Spring Boot中集成Lucence</h1>
<h2 id="1-lucence-和全文检索">1. Lucence 和全文检索</h2>
<p>Lucene 是什么？看一下百度百科：</p>
<blockquote>
<p>Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》</p>
</blockquote>
<h3 id="11-全文检索">1.1 全文检索</h3>
<p>这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。</p>
<p>何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。</p>
<p>文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。</p>
<h3 id="12-lucene-建立索引的方式">1.2 Lucene 建立索引的方式</h3>
<p>那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下：</p>
<blockquote>
<p>文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.<br>
文章2的内容为：He once lived in Shanghai.</p>
</blockquote>
<p>首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下：</p>
<blockquote>
<p>文章1经过分词后的结果：<code>[Tom]</code> <code>[lives]</code> <code>[Guangzhou]</code> <code>[I]</code> <code>[live]</code> <code>[Guangzhou]</code><br>
文章2经过分词后的结果：<code>[He]</code> <code>[lives]</code> <code>[Shanghai]</code></p>
</blockquote>
<p>然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下：</p>
<blockquote>
<p>文章1经过处理后的结果：<code>[tom]</code> <code>[live]</code> <code>[guangzhou]</code> <code>[i]</code> <code>[live]</code> <code>[guangzhou]</code><br>
文章2经过处理后的结果：<code>[he]</code> <code>[live]</code> <code>[shanghai]</code></p>
</blockquote>
<p>最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键词</th>
<th style="text-align:center">文章号[出现频率]</th>
<th style="text-align:center">出现位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">guangzhou</td>
<td style="text-align:center">1[2]</td>
<td style="text-align:center">3,6</td>
</tr>
<tr>
<td style="text-align:center">he</td>
<td style="text-align:center">2[1]</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">1[1]</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">live</td>
<td style="text-align:center">1[2],2[1]</td>
<td style="text-align:center">2,5,2</td>
</tr>
<tr>
<td style="text-align:center">shanghai</td>
<td style="text-align:center">2[1]</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">tom</td>
<td style="text-align:center">1[1]</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。<br>
搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。</p>
<p>理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。</p>
<h2 id="2-spring-boot-中集成-lucence">2. Spring Boot 中集成 Lucence</h2>
<h3 id="21-依赖导入-4">2.1 依赖导入</h3>
<p>首先需要导入 Lucene 的依赖，它的依赖有好几个，如下：</p>
<pre><code class="language-xml">&lt;!-- Lucence核心包 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
	&lt;artifactId&gt;lucene-core&lt;/artifactId&gt;
	&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Lucene查询解析包 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
	&lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt;
	&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 常规的分词（英文） --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
	&lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt;
	&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--支持分词高亮  --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
	&lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt;
	&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--支持中文分词  --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
	&lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt;
	&lt;version&gt;5.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。</p>
<h3 id="22-快速入门">2.2 快速入门</h3>
<p>根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。</p>
<h4 id="221-建立索引">2.2.1 建立索引</h4>
<p>我们自己弄几个文件，放到 <code>D:\lucene\data</code> 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。</p>
<pre><code class="language-java">public class Indexer {

    /**
     * 写索引实例
     */
    private IndexWriter writer;

    /**
     * 构造方法，实例化IndexWriter
     * @param indexDir
     * @throws Exception
     */
    public Indexer(String indexDir) throws Exception {
        Directory dir = FSDirectory.open(Paths.get(indexDir));
        //标准分词器，会自动去掉空格啊，is a the等单词
        Analyzer analyzer = new StandardAnalyzer();
        //将标准分词器配到写索引的配置中
        IndexWriterConfig config = new IndexWriterConfig(analyzer);
        //实例化写索引对象
        writer = new IndexWriter(dir, config);
    }
}
</code></pre>
<p>在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。</p>
<pre><code class="language-java">/**
 * 索引指定目录下的所有文件
 * @param dataDir
 * @return
 * @throws Exception
 */
public int indexAll(String dataDir) throws Exception {
    // 获取该路径下的所有文件
    File[] files = new File(dataDir).listFiles();
    if (null != files) {
        for (File file : files) {
            //调用下面的indexFile方法，对每个文件进行索引
            indexFile(file);
        }
    }
    //返回索引的文件数
    return writer.numDocs();
}

/**
 * 索引指定的文件
 * @param file
 * @throws Exception
 */
private void indexFile(File file) throws Exception {
    System.out.println(&quot;索引文件的路径：&quot; + file.getCanonicalPath());
    //调用下面的getDocument方法，获取该文件的document
    Document doc = getDocument(file);
    //将doc添加到索引中
    writer.addDocument(doc);
}

/**
 * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录
 * @param file
 * @return
 * @throws Exception
 */
private Document getDocument(File file) throws Exception {
    Document doc = new Document();
    //开始添加字段
    //添加内容
    doc.add(new TextField(&quot;contents&quot;, new FileReader(file)));
    //添加文件名，并把这个字段存到索引文件里
    doc.add(new TextField(&quot;fileName&quot;, file.getName(), Field.Store.YES));
    //添加文件路径
    doc.add(new TextField(&quot;fullPath&quot;, file.getCanonicalPath(), Field.Store.YES));
    return doc;
}
</code></pre>
<p>这样就建立好索引了，我们在该类中写一个 main 方法测试一下：</p>
<pre><code class="language-java">public static void main(String[] args) {
        //索引保存到的路径
        String indexDir = &quot;D:\\lucene&quot;;
        //需要索引的文件数据存放的目录
        String dataDir = &quot;D:\\lucene\\data&quot;;
        Indexer indexer = null;
        int indexedNum = 0;
        //记录索引开始时间
        long startTime = System.currentTimeMillis();
        try {
            // 开始构建索引
            indexer = new Indexer(indexDir);
            indexedNum = indexer.indexAll(dataDir);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != indexer) {
                    indexer.close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        //记录索引结束时间
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;索引耗时&quot; + (endTime - startTime) + &quot;毫秒&quot;);
        System.out.println(&quot;共索引了&quot; + indexedNum + &quot;个文件&quot;);
    }
</code></pre>
<p>我搞了两个 tomcat 相关的文件放到 <code>D:\lucene\data</code> 下了，执行完之后，看到控制台输出：</p>
<pre><code>索引文件的路径：D:\lucene\data\catalina.properties
索引文件的路径：D:\lucene\data\logging.properties
索引耗时882毫秒
共索引了2个文件
</code></pre>
<p>然后我们去 <code>D:\lucene\</code> 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。</p>
<p>####2.2.2 检索内容</p>
<p>上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。</p>
<pre><code class="language-java">public class Searcher {

    public static void search(String indexDir, String q) throws Exception {

        //获取要查询的路径，也就是索引所在的位置
        Directory dir = FSDirectory.open(Paths.get(indexDir));
        IndexReader reader = DirectoryReader.open(dir);
        //构建IndexSearcher
        IndexSearcher searcher = new IndexSearcher(reader);
        //标准分词器，会自动去掉空格啊，is a the等单词
        Analyzer analyzer = new StandardAnalyzer();
        //查询解析器
        QueryParser parser = new QueryParser(&quot;contents&quot;, analyzer);
        //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串
        Query query = parser.parse(q);

        //记录索引开始时间
        long startTime = System.currentTimeMillis();
        //开始查询，查询前10条数据，将记录保存在docs中
        TopDocs docs = searcher.search(query, 10);
        //记录索引结束时间
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;匹配&quot; + q + &quot;共耗时&quot; + (endTime-startTime) + &quot;毫秒&quot;);
        System.out.println(&quot;查询到&quot; + docs.totalHits + &quot;条记录&quot;);

        //取出每条查询结果
        for(ScoreDoc scoreDoc : docs.scoreDocs) {
            //scoreDoc.doc相当于docID,根据这个docID来获取文档
            Document doc = searcher.doc(scoreDoc.doc);
            //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。
            System.out.println(doc.get(&quot;fullPath&quot;));
        }
        reader.close();
    }
}
</code></pre>
<p>ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下：</p>
<pre><code class="language-java">public static void main(String[] args) {
    String indexDir = &quot;D:\\lucene&quot;;
    //查询这个字符串
    String q = &quot;security&quot;;
    try {
        search(indexDir, q);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<p>查一下 <code>security</code> 这个字符串，执行一下看控制台打印的结果：</p>
<pre><code>匹配security共耗时23毫秒
查询到1条记录
D:\lucene\data\catalina.properties
</code></pre>
<p>可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。</p>
<h3 id="23-中文分词检索高亮实战">2.3 中文分词检索高亮实战</h3>
<p>上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。</p>
<h4 id="231-中文分词">2.3.1 中文分词</h4>
<p>我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下：</p>
<pre><code class="language-java">public class ChineseIndexer {

    /**
     * 存放索引的位置
     */
    private Directory dir;

    //准备一下用来测试的数据
    //用来标识文档
    private Integer ids[] = {1, 2, 3};
    private String citys[] = {&quot;上海&quot;, &quot;南京&quot;, &quot;青岛&quot;};
    private String descs[] = {
            &quot;上海是个繁华的城市。&quot;,
            &quot;南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。&quot;,
            &quot;青岛是一个美丽的城市。&quot;
    };

    /**
     * 生成索引
     * @param indexDir
     * @throws Exception
     */
    public void index(String indexDir) throws Exception {
        dir = FSDirectory.open(Paths.get(indexDir));
        // 先调用 getWriter 获取IndexWriter对象
        IndexWriter writer = getWriter();
        for(int i = 0; i &lt; ids.length; i++) {
            Document doc = new Document();
            // 把上面的数据都生成索引，分别用id、city和desc来标识
            doc.add(new IntField(&quot;id&quot;, ids[i], Field.Store.YES));
            doc.add(new StringField(&quot;city&quot;, citys[i], Field.Store.YES));
            doc.add(new TextField(&quot;desc&quot;, descs[i], Field.Store.YES));
            //添加文档
            writer.addDocument(doc);
        }
        //close了才真正写到文档中
        writer.close();
    }

    /**
     * 获取IndexWriter实例
     * @return
     * @throws Exception
     */
    private IndexWriter getWriter() throws Exception {
        //使用中文分词器
        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();
        //将中文分词器配到写索引的配置中
        IndexWriterConfig config = new IndexWriterConfig(analyzer);
        //实例化写索引对象
        IndexWriter writer = new IndexWriter(dir, config);
        return writer;
    }

    public static void main(String[] args) throws Exception {
        new ChineseIndexer().index(&quot;D:\\lucene2&quot;);
    }
}
</code></pre>
<p>这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。<br>
然后执行一下 main 方法，将索引保存到 <code>D:\lucene2\</code> 中。</p>
<h4 id="232-中文分词查询">2.3.2 中文分词查询</h4>
<p>中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释：</p>
<pre><code class="language-java">public class ChineseSearch {

    private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class);

    public static List&lt;String&gt; search(String indexDir, String q) throws Exception {

        //获取要查询的路径，也就是索引所在的位置
        Directory dir = FSDirectory.open(Paths.get(indexDir));
        IndexReader reader = DirectoryReader.open(dir);
        IndexSearcher searcher = new IndexSearcher(reader);
        //使用中文分词器
        SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer();
        //由中文分词器初始化查询解析器
        QueryParser parser = new QueryParser(&quot;desc&quot;, analyzer);
        //通过解析要查询的String，获取查询对象
        Query query = parser.parse(q);

        //记录索引开始时间
        long startTime = System.currentTimeMillis();
        //开始查询，查询前10条数据，将记录保存在docs中
        TopDocs docs = searcher.search(query, 10);
        //记录索引结束时间
        long endTime = System.currentTimeMillis();
        logger.info(&quot;匹配{}共耗时{}毫秒&quot;, q, (endTime - startTime));
        logger.info(&quot;查询到{}条记录&quot;, docs.totalHits);

        //如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt;
        SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(&quot;&lt;b&gt;&lt;font color=red&gt;&quot;,&quot;&lt;/font&gt;&lt;/b&gt;&quot;);
        //根据查询对象计算得分，会初始化一个查询结果最高的得分
        QueryScorer scorer = new QueryScorer(query);
        //根据这个得分计算出一个片段
        Fragmenter fragmenter = new SimpleSpanFragmenter(scorer);
        //将这个片段中的关键字用上面初始化好的高亮格式高亮
        Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer);
        //设置一下要显示的片段
        highlighter.setTextFragmenter(fragmenter);

        //取出每条查询结果
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for(ScoreDoc scoreDoc : docs.scoreDocs) {
            //scoreDoc.doc相当于docID,根据这个docID来获取文档
            Document doc = searcher.doc(scoreDoc.doc);
            logger.info(&quot;city:{}&quot;, doc.get(&quot;city&quot;));
            logger.info(&quot;desc:{}&quot;, doc.get(&quot;desc&quot;));
            String desc = doc.get(&quot;desc&quot;);

            //显示高亮
            if(desc != null) {
                TokenStream tokenStream = analyzer.tokenStream(&quot;desc&quot;, new StringReader(desc));
                String summary = highlighter.getBestFragment(tokenStream, desc);
                logger.info(&quot;高亮后的desc:{}&quot;, summary);
                list.add(summary);
            }
        }
        reader.close();
        return list;
    }
}
</code></pre>
<p>每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。</p>
<h4 id="233-测试一下">2.3.3 测试一下</h4>
<p>这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下：</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/lucene&quot;)
public class IndexController {

    @GetMapping(&quot;/test&quot;)
    public String test(Model model) {
        // 索引所在的目录
        String indexDir = &quot;D:\\lucene2&quot;;
        // 要查询的字符
//        String q = &quot;南京文明&quot;;
        String q = &quot;南京文化&quot;;
        try {
            List&lt;String&gt; list = ChineseSearch.search(indexDir, q);
            model.addAttribute(&quot;list&quot;, list);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return &quot;result&quot;;
    }
}
</code></pre>
<p>直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。</p>
<pre><code class="language-xml">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div th:each=&quot;desc : ${list}&quot;&gt;
    &lt;div th:utext=&quot;${desc}&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里注意一下，不能使用 <code>th:test</code>，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 <code>http://localhost:8080/lucene/test</code>，测试一下效果，我们搜索的是 “南京文化”。</p>
<figure data-type="image" tabindex="21"><img src="https://images.gitbook.cn/83b3f810-b377-11e8-88bf-23cb78d1fb4f" alt="南京文化" loading="lazy"></figure>
<p>再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。</p>
<figure data-type="image" tabindex="22"><img src="https://images.gitbook.cn/8ef8a4a0-b377-11e8-911d-27cc5f059829" alt="南京文明" loading="lazy"></figure>
<p>可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。</p>
<h2 id="3-总结-4">3. 总结</h2>
<p>本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
<p><a name="搭建实际项目开发中的架构"></a></p>
<h1 id="spring-boot搭建实际项目开发中的架构">Spring Boot搭建实际项目开发中的架构</h1>
<p>前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。</p>
<p>不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。</p>
<p>从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p>
<p>结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。</p>
<figure data-type="image" tabindex="23"><img src="https://images.gitbook.cn/6f23c980-b89e-11e8-87f1-559c9b456754" alt="工程架构" loading="lazy"></figure>
<h2 id="1-统一的数据封装">1. 统一的数据封装</h2>
<p>由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下：</p>
<pre><code>/**
 * 统一返回对象
 * @author shengwu ni
 * @param &lt;T&gt;
 */
public class JsonResult&lt;T&gt; {

    private T data;
    private String code;
    private String msg;

    /**
     * 若没有数据返回，默认状态码为0，提示信息为：操作成功！
     */
    public JsonResult() {
        this.code = &quot;0&quot;;
        this.msg = &quot;操作成功！&quot;;
    }

    /**
     * 若没有数据返回，可以人为指定状态码和提示信息
     * @param code
     * @param msg
     */
    public JsonResult(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    /**
     * 有数据返回时，状态码为0，默认提示信息为：操作成功！
     * @param data
     */
    public JsonResult(T data) {
        this.data = data;
        this.code = &quot;0&quot;;
        this.msg = &quot;操作成功！&quot;;
    }

    /**
     * 有数据返回，状态码为0，人为指定提示信息
     * @param data
     * @param msg
     */
    public JsonResult(T data, String msg) {
        this.data = data;
        this.code = &quot;0&quot;;
        this.msg = msg;
    }
    
    /**
     * 使用自定义异常作为参数传递状态码和提示信息
     * @param msgEnum
     */
    public JsonResult(BusinessMsgEnum msgEnum) {
        this.code = msgEnum.code();
        this.msg = msgEnum.msg();
    }

    // 省去get和set方法
}
</code></pre>
<p>大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。</p>
<h2 id="2-json的处理">2. json的处理</h2>
<p>Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。</p>
<pre><code class="language-java">/**
 * jacksonConfig
 * @author shengwu ni
 */
@Configuration
public class JacksonConfig {
    @Bean
    @Primary
    @ConditionalOnMissingBean(ObjectMapper.class)
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper objectMapper = builder.createXmlMapper(false).build();
        objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() {
            @Override
            public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
                jsonGenerator.writeString(&quot;&quot;);
            }
        });
        return objectMapper;
    }
}
</code></pre>
<p>这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。</p>
<h2 id="3-swagger2在线可调式接口">3. swagger2在线可调式接口</h2>
<p>有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置：</p>
<pre><code class="language-java">/**
 * swagger配置
 * @author shengwu ni
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                // 指定构建api文档的详细信息的方法：apiInfo()
                .apiInfo(apiInfo())
                .select()
                // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口
                .apis(RequestHandlerSelectors.basePackage(&quot;com.itcodai.course18.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * 构建api文档的详细信息
     * @return
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                // 设置页面标题
                .title(&quot;Spring Boot搭建实际项目中开发的架构&quot;)
                // 设置接口描述
                .description(&quot;跟武哥一起学Spring Boot第18课&quot;)
                // 设置联系方式
                .contact(&quot;倪升武，&quot; + &quot;微信公众号：程序员私房菜&quot;)
                // 设置版本
                .version(&quot;1.0&quot;)
                // 构建
                .build();
    }
}
</code></pre>
<p>到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。</p>
<pre><code class="language-java">@RestController
@Api(value = &quot;用户信息接口&quot;)
public class UserController {

    @Resource
    private UserService userService;

    @GetMapping(&quot;/getUser/{id}&quot;)
    @ApiOperation(value = &quot;根据用户唯一标识获取用户信息&quot;)
    public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = &quot;用户唯一标识&quot;) Long id) {
        User user = new User(id, &quot;倪升武&quot;, &quot;123456&quot;);
        return new JsonResult&lt;&gt;(user);
    }
}
</code></pre>
<p>然后启动项目，在浏览器中输入 <code>localhost:8080/swagger-ui.html</code> 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。</p>
<h2 id="4-持久层集成">4. 持久层集成</h2>
<p>每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。</p>
<pre><code class="language-yml"># 服务端口号
server:
  port: 8080

# 数据库地址
datasource:
  url: localhost:3306/blog_test

spring:
  datasource: # 数据库配置
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10
    username: root
    password: 123456
    hikari:
      maximum-pool-size: 10 # 最大连接池数
      max-lifetime: 1770000

mybatis:
  # 指定别名设置的包为所有entity
  type-aliases-package: com.itcodai.course18.entity
  configuration:
    map-underscore-to-camel-case: true # 驼峰命名规范
  mapper-locations: # mapper映射文件位置
    - classpath:mapper/*.xml
</code></pre>
<p>配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。</p>
<pre><code class="language-java">public interface UserMapper {

    @Select(&quot;select * from user where id = #{id}&quot;)
    @Results({
            @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),
            @Result(property = &quot;password&quot;, column = &quot;password&quot;)
    })
    User getUser(Long id);

    @Select(&quot;select * from user where id = #{id} and user_name=#{name}&quot;)
    User getUserByIdAndName(@Param(&quot;id&quot;) Long id, @Param(&quot;name&quot;) String username);

    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; getAll();
}
</code></pre>
<p>关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 <code>@MapperScan(&quot;com.itcodai.course18.dao&quot;)</code></p>
<h2 id="5-拦截器">5. 拦截器</h2>
<p>拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。</p>
<pre><code class="language-java">public class MyInterceptor implements HandlerInterceptor {

    private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class);

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        logger.info(&quot;执行方法之前执行(Controller方法调用之前)&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.info(&quot;执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.info(&quot;整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了&quot;);
    }
}
</code></pre>
<p>然后将自定义的拦截器加入到拦截器配置中。</p>
<pre><code class="language-java">@Configuration
public class MyInterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 实现WebMvcConfigurer不会导致静态资源被拦截
        registry.addInterceptor(new MyInterceptor())
                // 拦截所有url
                .addPathPatterns(&quot;/**&quot;)
                // 放行swagger
                .excludePathPatterns(&quot;/swagger-resources/**&quot;);
    }
}
</code></pre>
<p>在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源：</p>
<blockquote>
<p>classpath:/static<br>
classpath:/public<br>
classpath:/resources<br>
classpath:/META-INF/resources</p>
</blockquote>
<p>上面代码中配置的 <code>/**</code> 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。</p>
<p>然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。</p>
<h2 id="6-全局异常处理">6. 全局异常处理</h2>
<p>全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下：</p>
<pre><code class="language-java">public enum BusinessMsgEnum {
    /** 参数异常 */
    PARMETER_EXCEPTION(&quot;102&quot;, &quot;参数异常!&quot;),
    /** 等待超时 */
    SERVICE_TIME_OUT(&quot;103&quot;, &quot;服务调用超时！&quot;),
    /** 参数过大 */
    PARMETER_BIG_EXCEPTION(&quot;102&quot;, &quot;输入的图片数量不能超过50张!&quot;),
    /** 500 : 发生异常 */
    UNEXPECTED_EXCEPTION(&quot;500&quot;, &quot;系统发生异常，请联系管理员！&quot;);

    /**
     * 消息码
     */
    private String code;
    /**
     * 消息内容
     */
    private String msg;

    private BusinessMsgEnum(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public String code() {
        return code;
    }

    public String msg() {
        return msg;
    }

}
</code></pre>
<p>在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。</p>
<pre><code class="language-java">@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 拦截业务异常，返回业务异常信息
     * @param ex
     * @return
     */
    @ExceptionHandler(BusinessErrorException.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleBusinessError(BusinessErrorException ex) {
        String code = ex.getCode();
        String message = ex.getMessage();
        return new JsonResult(code, message);
    }

    /**
     * 空指针异常
     * @param ex NullPointerException
     * @return
     */
    @ExceptionHandler(NullPointerException.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleTypeMismatchException(NullPointerException ex) {
        logger.error(&quot;空指针异常，{}&quot;, ex.getMessage());
        return new JsonResult(&quot;500&quot;, &quot;空指针异常了&quot;);
    }

    /**
     * 系统异常 预期以外异常
     * @param ex
     * @return
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR)
    public JsonResult handleUnexpectedServer(Exception ex) {
        logger.error(&quot;系统异常：&quot;, ex);
        return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION);
    }
}
</code></pre>
<p>其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。<br>
在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。</p>
<h2 id="7-总结">7. 总结</h2>
<p>本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。</p>
<p>课程源代码下载地址：<a href="https://gitee.com/eson15/springboot_study">戳我下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HashMap扰动函数]]></title>
        <id>https://zerononet.github.io/post/hashmap-rao-dong-han-shu/</id>
        <link href="https://zerononet.github.io/post/hashmap-rao-dong-han-shu/">
        </link>
        <updated>2020-11-19T06:57:51.000Z</updated>
        <content type="html"><![CDATA[<h4>上源码</h4>
JDK8
<blockquote>
<p>// 以下来源JDK8源码：<br> // 找到元素在数组中的位置，n为数组长度。<br>  　i = (n - 1) &amp; hash</p>
<p>// 计算Key的Hash值<br> static final int hash(Object key) {<br> 　　int h;<br> 　　return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br> 　}</p>
</blockquote>
<p>JDK7</p>
<blockquote>
<p>static int indexFor(int h, int length) { <br>//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理相同<br> 　　return h &amp; (length-1); //第三步 取模运算<br> 　}</p>
</blockquote>
<p>三部曲：这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算。</strong><br>
<br><font color="green" ><strong>扰动目的</strong></font>：任意的key计算出的数组下标都能足够散列，尽量均匀分布，减少Hash碰撞，就能减少链表长度，虽然JDK8以后链表长度超过8会转成红黑树。<br>
<br>由于Hash值是int类型的，所以需要很长的的数组，但现实情况是数组的长度是有限的，所以<font color="blue">取低几位的运算会得到相对满足的散列值。而任何2的整数幂，减一得到的二进制位全部是一。</font>如：16-1=15，二进制表示为：1111；32-1=31，二进制表示为：11111。所以让Hash值与（&amp;）上n-1后得到的就是低位Hash值，例如：</p>
<blockquote>
<p>   00100100 10100101 11000100 00100101    // Hash值<br> &amp;   00000000 00000000 00000000 00001111    // 16 - 1 = 15<br> 　-----------------------------------------------------<br> 　00000000 00000000 00000000 00000101    // 高位全部归零，只保留末四位。</p>
</blockquote>
<p><br>但是如果只是简单的取最后几位，碰撞也会非常严重。如果再加上散列本身做的不好的话，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复。就会加大链表长度。<br>
<br><strong>正片来了</strong>：<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/20201119142954.png" alt="扰动函数二进制计算步骤" loading="lazy"></center><br>
<br><center>异或运算</center><br>
<br>右移16bit，正好是32bit的一半，用自己的高位区跟低位区做异或，不仅能保留高低位信息，又可以使得在低位区相同高位区不同的Hash值可以得到较好的散列随机性，减少碰撞。</p>
<blockquote>
<p>// Hash碰撞示例：<br> H1: 00000000 00000000 00000000 00000101 &amp; 1111 = 0101<br> H2: 00000000 11111111 00000000 00000101 &amp; 1111 = 0101</p>
</blockquote>
<blockquote>
<p>//扰动示例<br> 00000000 00000000 00000000 00000101 // H1<br>00000000 00000000 00000000 00000000 // H1 &gt;&gt;&gt; 16<br>00000000 00000000 00000000 00000101 // hash = H1 ^ (H1 &gt;&gt;&gt; 16) = 5<br><br>00000000 11111111 00000000 00000101 // H2<br>00000000 00000000 00000000 11111111 // H2 &gt;&gt;&gt; 16<br>00000000 00000000 00000000 11111010 // hash = H2 ^ (H2 &gt;&gt;&gt; 16) = 250</p>
</blockquote>
<p>最终结果：</p>
<blockquote>
<p>// 没有Hash碰撞<br>index1 = (n - 1) &amp; H1 = (16 - 1) &amp; 5 = 5<br>index2 = (n - 1) &amp; H2 = (16 - 1) &amp; 250 = 10</p>
</blockquote>
<p><br>问题回忆：为什么HashMap的长度是2的整数幂？为什么扰动后要跟数组长度-1做与运算？</p>
<font color="white">
<br><center>彩蛋：</center>
异或运算规则：(同为0，异为1)<br>与运算规则：0&0=0;0&1=0;1&0=0;1&1=1;
</font>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[知识点备查手册(持续更新中)]]></title>
        <id>https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/</id>
        <link href="https://zerononet.github.io/post/zhi-shi-dian-bei-cha-shou-ce/">
        </link>
        <updated>2020-11-17T02:23:54.000Z</updated>
        <content type="html"><![CDATA[<center> <h1><strong> 目录</strong> </h1> </center>
<center><strong><h2>设计模式之七大原则</h2></strong></center>
<center><a href="#开闭原则">开闭原则</a></center>
<center><a href="#里氏替换原则">里氏替换原则</a></center>
<center><a href="#依赖倒置原则">依赖倒置原则</a></center>
<center><a href="#单一职责原则">单一职责原则</a></center>
<center><a href="#接口隔离原则">接口隔离原则</a></center>
<center><a href="#迪米特法则">迪米特法则</a></center>
<center><a href="#合成复用原则">合成复用原则</a></center>
<center><strong><h2>设计模式</h2></strong></center>
<center><a href="#简单工厂模式">简单工厂模式</a></center>
<center><a href="#工厂方法模式">工厂方法模式</a></center>
<center><a href="#抽象工厂模式">抽象工厂模式</a></center>
<center><a href="#建造者模式">建造者模式</a></center>
<center><a href="#单例模式">单例模式</a></center>
<center><a href="#原型模式">原型模式</a></center>
<center><a href="#外观模式">外观模式</a></center>
<center><a href="#装饰模式">装饰模式</a></center>
<center><a href="#适配器模式">适配器模式</a></center>
<center><a href="#亨元模式">亨元模式</a></center>
<center><a href="#组合模式">组合模式</a></center>
<center><a href="#桥接模式">桥接模式</a></center>
<center><a href="#代理模式">代理模式</a></center>
<center><a href="#模板方法模式">模板方法模式</a></center>
<center><a href="#迭代器模式">迭代器模式</a></center>
<center><a href="#策略模式">策略模式</a></center>
<center><a href="#解释器模式">解释器模式</a></center>
<center><a href="#观察者模式">观察者模式</a></center>
<center><a href="#备忘录模式">备忘录模式</a></center>
<center><a href="#命令模式">命令模式</a></center>
<center><a href="#中介者模式">中介者模式</a></center>
<center><a href="#责任链模式">责任链模式</a></center>
<center><a href="#访问者模式">访问者模式</a></center>
<center><a href="#状态模式">状态模式</a></center>
<center><strong><h2>JAVA并发编程</h2></strong></center>
<center><a href="#volatile">volatile</a></center>
<center><a href="#JAVA8如何优化CAS性能">JAVA8如何优化CAS性能</a></center>
<center><a href="#各种锁的应用场景">各种锁的应用场景</a></center>
<center><strong><h2>JVM底层</h2></strong></center>
<center><a href="#垃圾回收">垃圾回收</a></center>
<center><a href="#AQS(AbstractQueuedSynchronizer)抽象队列同步器">AQS(AbstractQueuedSynchronizer)抽象队列同步器</a></center>
<center><a href="#ArrayList">ArrayList</a></center>
<center><a href="#HashMap底层实现">HashMap底层实现</a></center>
<center><a href="#ConcurrentHashMap底层实现">ConcurrentHashMap底层实现</a></center>
<center><a href="#JAVA代理">JAVA代理</a></center>
<center><strong><h2>Spring框架</h2></strong></center>
<center><a href="#SpringBoot">SpringBoot</a></center>
<center><a href="#Spring-IOC">Spring IOC</a></center>
<center><a href="#Spring-AOP">Spring AOP</a></center>
<center><strong><h2>Redis</h2></strong></center>
<center><a href="#五大数据结构">五大数据结构</a></center>
<center><a href="#缓存过期">缓存过期</a></center>
<center><a href="#持久化">持久化</a></center>
<center><a href="#同步机制">同步机制</a></center>
<center><a href="#集群与高可用">集群与高可用</a></center>
<center><a href="#分布式锁">分布式锁</a></center>
<center><a href="#跳跃表">跳跃表</a></center>
<center><strong><h2>数据结构与算法</h2></strong></center>
<center><a href="#红黑树(自平衡二叉查找树)">红黑树(自平衡二叉查找树)</a></center>
<h2 id="设计模式">设计模式</h2>
<p><a href="https://www.cnblogs.com/pony1223/p/7608955.html">总结参考</a><br>
<br><a href="https://juejin.im/post/6844903695667167240">掘金JAVA设计模式</a><br>
<br><center>设计模式分类<br>
<img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/401339-20170928225241215-295252070.png" alt="设计模式分类" loading="lazy"></center></p>
<h3 id="01-七大原则">0.1、七大原则</h3>
<p><a name="开闭原则"></a></p>
<ol>
<li><strong><a href="http://c.biancheng.net/view/1322.html">开闭原则</a></strong><br>
<br>&lt;<strong>定义：</strong>&gt;<br>1.软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。<br>2.开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。<br>&lt;<strong>作用：</strong>&gt;<br>1.对软件测试的影响：软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2.提高代码的可复用性：粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>&lt;<strong>实现：</strong>&gt;<br>&lt;a&gt;可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>&lt;b&gt;由于抽象类的灵活性好，适应性广的特点。可以作为软件的架构主心骨。当需要变化而不影响原本功能的情况下，可以根据需要派生一个实现类扩展即可。</li>
</ol>
<p><a name="里氏替换原则"></a><br>
2. <strong><a href="http://c.biancheng.net/view/1324.html">里氏替换原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，<strong>是对开闭原则的补充，是对实现抽象化的具体步骤的规范</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.里氏替换原则是实现开闭原则的重要方式之一。<br>2.它克服了继承中重写父类造成的可复用性变差的缺点。<br>3.它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。<br>4.加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。<br>&lt;<strong>实现：</strong>&gt;<br>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2.子类中可以增加自己特有的方法。<br>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。<br>4.当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</p>
<p><a name="依赖倒置原则"></a><br>
3. <strong><a href="http://c.biancheng.net/view/1326.html">依赖倒置原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。<strong>其核心思想是：要面向接口编程，不要面向实现编程。</strong><br>&lt;<strong>作用：</strong>&gt;<br>1.依赖倒置原则可以降低类间的耦合性。<br>2.依赖倒置原则可以提高系统的稳定性。<br>3.依赖倒置原则可以减少并行开发引起的风险。<br>4.依赖倒置原则可以提高代码的可读性和可维护性。<br>&lt;<strong>实现：</strong>&gt;<br>1.每个类尽量提供接口或抽象类，或者两者都具备。<br>2.变量的声明类型尽量是接口或者是抽象类。<br>3.任何类都不应该从具体类派生。<br>4.使用继承时尽量遵循里氏替换原则。</p>
<p><a name="单一职责原则"></a><br>
4. <strong><a href="http://c.biancheng.net/view/1327.html">单一职责原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。<br>1.降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>2.提高类的可读性。复杂性降低，自然其可读性会提高。<br>3.提高系统的可维护性。可读性提高，那自然更容易维护了。<br>4.变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。<br>&lt;<strong>实现：</strong>&gt;<br>1.单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。<br>2.单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p>
<p><a name="接口隔离原则"></a><br>
5. <strong><a href="http://c.biancheng.net/view/1330.html">接口隔离原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br><strong>对比：</strong>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>1.单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>2.单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。<br>&lt;<strong>作用(优点)：</strong>&gt;<br>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下5个优点<br>1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3.如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。<br>&lt;<strong>实现：</strong>&gt;<br>1.接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>2.为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>3.了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>4.提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
<p><a name="迪米特法则"></a><br>
6. <strong><a href="http://c.biancheng.net/view/1331.html">迪米特法则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。<br>&lt;<strong>作用：</strong>&gt;<br>1.降低了类之间的耦合度，提高了模块的相对独立性。<br>2.由于亲合度降低，从而提高了类的可复用率和系统的扩展性。<br>&lt;<strong>实现：</strong>&gt;<br>强调1.从依赖者的角度来说，只依赖应该依赖的对象。<br>强调2.从被依赖者的角度说，只暴露应该暴露的方法。<br>注意1.在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>注意2.在类的结构设计上，尽量降低类成员的访问权限。<br>注意3.在类的设计上，优先考虑将一个类设置成不变类。<br>注意4.在对其他类的引用上，将引用其他对象的次数降到最低。<br>注意5.不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>注意6.谨慎使用序列化（Serializable）功能。</p>
<p><a name="合成复用原则"></a><br>
7. <strong><a href="http://c.biancheng.net/view/1333.html">合成复用原则</a></strong><br>&lt;<strong>定义：</strong>&gt;<br>1.它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>2.如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。<br>&lt;<strong>作用：</strong>&gt;<br>优点1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>优点2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>优点3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。<br>缺点1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>缺点2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>缺点3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。<br>&lt;<strong>实现：</strong>&gt;<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。<br>
<br><h3>小结：</h3>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。<br>
<a name="简单工厂模式"></a></p>
<h3 id="1-简单工厂模式">1、<a href="http://c.biancheng.net/view/8385.html">简单工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jiandangongchang.png" alt="工厂方法模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>    定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。<br>    如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。<br>    在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li>
<li><strong>优点</strong><br>1.工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。<br>2.客户端无需知道所创建具体产品的类名，只需知道参数即可。<br>3.也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
<li><strong>缺点</strong><br>1.简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。<br>2.使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。<br>3.系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。<br>4.简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
<li><strong>应用场景</strong><br></li>
<li><strong><font color="red">CFC总结：</font></strong>增加抽象产品的具体产品需要修改工厂类。</li>
</ul>
<p><a name="工厂方法模式"></a></p>
<h3 id="2-工厂方法模式">2、<a href="http://c.biancheng.net/view/1348.html">工厂方法模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/gongchang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</li>
<li><strong>优点</strong><br>1.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。<br>2.灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。<br>3.典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
<li><strong>缺点</strong><br>1.类的个数容易过多，增加复杂度。<br>2.增加了系统的抽象性和理解难度。<br>3.抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/3-1Q11413554DT.png" alt="工厂模式实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>相同产品等级(同类)增加，需要增加对应的工厂类。</li>
</ul>
<p><a name="抽象工厂模式"></a></p>
<h3 id="3-抽象工厂模式">3、<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：<br>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。<br><strong>抽象工厂（AbstractFactory）模式的定义</strong>：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dianqigongchangdechanpingdengjiyuchanpingzu.png" alt="电器工厂的产品等级与产品族" loading="lazy"></center></li>
<li><strong>优点</strong></li>
<li><strong>缺点</strong></li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/chouxianggongchangYY.png" alt="抽象工厂实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>工厂只能消费同产品簇，产品簇增加，工厂类增加。</li>
</ul>
<p><a name="建造者模式"></a></p>
<h3 id="4-建造者模式">4、<a href="http://c.biancheng.net/view/1354.html">建造者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozhe.png" alt="建造者模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</li>
<li><strong>优点</strong><br>1.封装性好，构建和表示分离。<br>2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。<br>3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
<li><strong>缺点</strong><br>1.产品的组成部分必须相同，这限制了其使用范围。<br>2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>结合</strong>：建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jianzaozheYY.png" alt="抽象工厂实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong></li>
</ul>
<p><a name="单例模式"></a></p>
<h3 id="5-单例模式">5、<a href="http://c.biancheng.net/view/1338.html">单例模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/danli.png" alt="单例模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong><br>单例模式有 3 个特点：<br>1.单例类只有一个实例对象；<br>2.该单例对象必须由单例类自行创建；<br>3.单例类对外提供一个访问该单例的全局访问点。</li>
<li><strong>优点</strong><br>1.单例模式可以保证内存里只有一个实例，减少了内存的开销。<br>2.可以避免对资源的多重占用。<br>3.单例模式设置全局访问点，可以优化和共享资源的访问。</li>
<li><strong>缺点</strong><br>1.单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。<br>2.在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。<br>3.单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong><font color="red">CFC总结：</font></strong>懒汉模式与饿汉模式中，懒汉虽然节省了初始化时对单例对象的初始化，但是由于每次都需要判断空，并且多线程下可能会有重复创建对象的线程不安全性。导致需要加volatile synchronized关键字，影响了性能。而饿汉模式在初始化时就已经加载了新的对象，而且所有后续的使用都只对这个单例对象做获取动作，不存在线程同步的问题，性能较好。</li>
</ul>
<p><a name="原型模式"></a></p>
<h3 id="6-原型模式">6、<a href="http://c.biancheng.net/view/1343.html">原型模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxing.png" alt="原型模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</li>
<li><strong>优点</strong><br>1.Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。<br>2.可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
<li><strong>缺点</strong><br>1.需要为每一个类都配置一个 clone 方法。<br>2.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。<br>3.当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/yuanxingYY.png" alt="原型模式的实际应用" loading="lazy"></center></li>
</ul>
<p><a name="外观模式"></a></p>
<h3 id="7-外观模式">7、<a href="http://c.biancheng.net/view/1369.html">外观模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguan.png" alt="外观模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：<font color="blue" >外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</font>在日常编码工作中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。</li>
<li><strong>优点</strong><br>1.降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>2.对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>3.降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
<li><strong>缺点</strong><br>1.不能很好地限制客户使用子系统类，很容易带来未知风险。<br>2.增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/waiguanYY.png" alt="外观模式实际应用" loading="lazy"></center></li>
</ul>
<p><a name="装饰模式"></a></p>
<h3 id="8-装饰模式">8、<a href="http://c.biancheng.net/view/1366.html">装饰模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshi.png" alt="装饰模式的结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：装饰（Decorator）指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</li>
<li><strong>优点</strong><br>1.装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用。<br>2.通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果。<br>3.装饰器模式完全遵守开闭原则。</li>
<li><strong>缺点</strong>：装饰模式会增加许多子类，过度使用会增加程序得复杂性。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangshiYY.png" alt="装饰模式实际应用" loading="lazy"></center></li>
</ul>
<p><a name="适配器模式"></a></p>
<h3 id="9-适配器模式">9、<a href="http://c.biancheng.net/view/1361.html">适配器模式</a></h3>
<ul>
<li><strong>类适配器UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-lei.png" alt="" loading="lazy"></center></li>
<li><strong>对象适配器UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqi-duixiang.png" alt="" loading="lazy"></center></li>
<li><strong>定义</strong><br>1.适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。<br>2.类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。现在来介绍它们的基本结构。</li>
<li><strong>优点</strong><br>1.客户端通过适配器可以透明地调用目标接口。<br>2.复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<br>3.将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。<br>4.在很多业务场景中符合开闭原则。</li>
<li><strong>缺点</strong><br>1.适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。<br>2.增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/shipeiqiYY.png" alt="发动机适配器实际应用" loading="lazy"></center></li>
<li><strong><font color="red">CFC总结：</font></strong>类适配器与对象适配器在简单且单一的时候是差不多的，但是当适配器需要处理复杂的适配的时候，涉及多种的情况下，对象适配器可以变种传入对象为传入继承该抽象基类对象的对象(Class&lt;? extends xxx&gt;)来实现多种复杂的适配。</li>
</ul>
<p><a name="亨元模式"></a></p>
<h3 id="10-亨元模式">10、<a href="http://c.biancheng.net/view/1371.html">亨元模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuan.png" alt="亨元模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</li>
<li><strong>优点</strong>1.相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</li>
<li><strong>缺点</strong>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>2.读取享元模式的外部状态会使得运行时间稍微变长。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/hengyuanYY.png" alt="亨元模式五子棋游戏实际应用" loading="lazy"></center></li>
</ul>
<p><a name="组合模式"></a></p>
<h3 id="11-组合模式">11、<a href="http://c.biancheng.net/view/1373.html">组合模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><strong>透明式组合模式</strong>中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如图所示。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuhe-touming.png" alt="透明式组合模式结构图" loading="lazy"></center><br>
<br><strong>安全式组合模式</strong>中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如图所示。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuhe-anquan.png" alt="安全式组合模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：组合（Composite Pattern）模式有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型设计模式。组合模式一般用来描述整体与部分的关系，它将对象组织到树形结构中，顶层的节点被称为根节点，根节点下面可以包含树枝节点和叶子节点，树枝节点下面又可以包含树枝节点和叶子节点，树形结构图如下。<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheshuxingjiegoutu.png" alt="组合模式树形结构图" loading="lazy"></center><br>
<br>由上图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利</li>
<li><strong>优点</strong><br>1.组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。<br>2.更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。</li>
<li><strong>缺点</strong><br>1.设计较复杂，客户端需要花更多时间理清类之间的层次关系。<br>2.不容易限制容器中的构件。<br>3.不容易用继承的方法来增加构件的新功能。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheYY-tjyj.gif" alt="组合模式实际应用" loading="lazy"></center></li>
<li><strong>复杂实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zuheYY-fuza.gif" alt="组合模式复杂应用" loading="lazy"></center></li>
</ul>
<p><a name="桥接模式"></a></p>
<h3 id="12-桥接模式">12、<a href="http://c.biancheng.net/view/1364.html">桥接模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojie.png" alt="桥接模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><strong>优点</strong><br>1.抽象与实现分离，扩展能力强。<br>2.符合开闭原则。<br>3.符合合成复用原则。<br>4.其实现细节对客户透明。</li>
<li><strong>缺点</strong><br>1.于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/qiaojieYY.png" alt="桥接模式实际应用" loading="lazy"></center></li>
</ul>
<p><a name="代理模式"></a></p>
<h3 id="13-代理模式">13、<a href="http://c.biancheng.net/view/1359.html">代理模式</a></h3>
<ul>
<li>
<p><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/daili.gif" alt="" loading="lazy"></center></p>
</li>
<li>
<p><strong>定义</strong>：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</li>
<li>
<p><strong>优点</strong><br>1.代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。<br>2.代理对象可以扩展目标对象的功能。<br>3.代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。</p>
</li>
<li>
<p><strong>缺点</strong><br>1.代理模式会造成系统设计中类的数量增加。<br>2.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。<br>3.增加了系统的复杂度。</p>
</li>
<li>
<p><strong>应用场景</strong>：当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。<br>
<br>1.远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。<br>2.虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。<br>3.安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。<br>4.智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。<br>5.延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</p>
</li>
<li>
<p><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dailiYY.gif" alt="代理模式实际应用" loading="lazy"></center></p>
</li>
<li>
<p><strong>动态代理UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/dailiKZdongtai.gif" alt="代理模式实际应用" loading="lazy"></center></p>
</li>
</ul>
<p><a name="模板方法模式"></a></p>
<h3 id="14-模板方法模式">14、<a href="http://c.biancheng.net/view/1376.html">模板方法模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfa.gif" alt="模板方法结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：模板方法（Template Method）定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</li>
<li><strong>优点</strong><br>1.它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。<br>2.它在父类中提取了公共的部分代码，便于代码复用。<br>3.部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
<li><strong>缺点</strong><br>1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。<br>2.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。<br>3.由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>
<li><strong>应用场景</strong><br>1.算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。<br>2.当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。<br>3.当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
<li><strong>扩展</strong>：在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图所示<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfahangouzi.png" alt="含钩子方法的模板方法模式的结构图" loading="lazy"></center></li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mubanfangfaYY.gif" alt="模板方法实际应用" loading="lazy"></center></li>
</ul>
<p><a name="迭代器模式"></a></p>
<h3 id="15-迭代器模式">15、<a href="http://c.biancheng.net/view/1395.html">迭代器模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/diedaiqi.gif" alt="迭代器结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：迭代器（Iterator）模式提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式</li>
<li><strong>优点</strong><br>1.访问一个聚合对象的内容而无须暴露它的内部表示。<br>2.遍历任务交由迭代器完成，这简化了聚合类。<br>3.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。<br>4.增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br>5.封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
<li><strong>缺点</strong><br>1.增加了类的个数，这在一定程度上增加了系统的复杂性。</li>
<li><strong>应用场景</strong><br>1.</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/diedaiqiYY.gif" alt="迭代器模式实际应用" loading="lazy"></center></li>
</ul>
<p><a name="策略模式"></a></p>
<h3 id="16-策略模式">16、<a href="http://c.biancheng.net/view/1378.html">策略模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celue.gif" alt="策略模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：策略（Strategy）模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</li>
<li><strong>优点</strong><br>1.多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句，如 if...else 语句、switch...case 语句。<br>2.策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。<br>3.策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。<br>4.策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。<br>5.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
<li><strong>缺点</strong><br>1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。<br>2.策略模式造成很多的策略类，增加维护难度。</li>
<li><strong>应用场景</strong>：策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。<br>1.一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。<br>2.一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。<br>3.系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。<br>4.系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。<br>5.多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celueYY.gif" alt="" loading="lazy"></center><br>
<br><center>大闸蟹做菜策略的结构图</center><br></li>
<li><strong>扩展</strong>：在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度，其结构图如图所示<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/celuegongchang.png" alt="策略工厂模式的结构图" loading="lazy"></center><br>
<br><center>策略工厂模式的结构图</center><br></li>
</ul>
<p><a name="解释器模式"></a></p>
<h3 id="17-解释器模式">17、<a href="http://c.biancheng.net/view/1402.html">解释器模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/jieshiqi.gif" alt="解释器模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：解释器（Interpreter）模式给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</li>
<li><strong>优点</strong><br>1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。<br>2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
<li><strong>缺点</strong><br>1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。<br>2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。<br>3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
<li><strong>应用场景</strong>：<br>1.当语言的文法较为简单，且执行效率不是关键问题时。<br>2.当问题重复出现，且可以用一种简单的语言来进行表达时。<br>3.当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。<br>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在 Java 中可以用 Expression4J 或 Jep 等来设计。</li>
<li><strong><font color="red">CFC总结：</font></strong>实现其实不难，举个拼接SQL的例子来说，只要一个Util类就可以实现。正常情况下我们可能在实际情况中有意无意的都会涉及点解释器模式的东西。</li>
</ul>
<p><a name="观察者模式"></a></p>
<h3 id="18-观察者模式">18、<a href="http://c.biancheng.net/view/1390.html">观察者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/guancazhe.gif" alt="" loading="lazy"></center></li>
<li><strong>定义</strong>：观察者（Observer）模式指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</li>
<li><strong>优点</strong><br>1.降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。<br>2.目标与观察者之间建立了一套触发机制。</li>
<li><strong>缺点</strong><br>1.目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。<br>2.当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
<li><strong>应用场景</strong><br>1.对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。<br>2.当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。<br>3.实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。<br>4.多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/guancazheYY.gif" alt="" loading="lazy"></center><br>
<br><center>人民币汇率分析程序的结构图</center></li>
</ul>
<p><a name="备忘录模式"></a></p>
<h3 id="19-备忘录模式">19、<a href="http://c.biancheng.net/view/1400.html">备忘录模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/beiwanglu.gif" alt="备忘录模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：备忘录（Memento）模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</li>
<li><strong>优点</strong><br>1.提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。<br>2.实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。<br>3.简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
<li><strong>缺点</strong><br>1.资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
<li><strong>应用场景</strong><br>1.需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。<br>2.需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/beiwangluYY.png" alt="" loading="lazy"></center><br>
<br><center>相亲游戏的结构图</center></li>
</ul>
<p><a name="命令模式"></a></p>
<h3 id="20-命令模式">20、<a href="http://c.biancheng.net/view/1380.html">命令模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/mingling.gif" alt="命令模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：命令（Command）模式将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</li>
<li><strong>优点</strong><br>1.通过引入中间件（抽象接口）降低系统的耦合度。<br>2.扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。<br>3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。<br>4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。<br>5.可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li>
<li><strong>缺点</strong><br>1.可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。<br>2.命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li>
<li><strong>应用场景</strong><br>1.请求调用者需要与请求接收者解耦时，命令模式可以使调用者和接收者不直接交互。<br>2.系统随机请求命令或经常增加、删除命令时，命令模式可以方便地实现这些功能。<br>3.当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。<br>4.当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/minglingYY.gif" alt="" loading="lazy"></center><br>
<br><center>客户在餐馆吃早餐的结构图</center></li>
</ul>
<p><a name="中介者模式"></a></p>
<h3 id="21-中介者模式">21、<a href="http://c.biancheng.net/view/1393.html">中介者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhongjiezhe.gif" alt="中介者模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：中介者（Mediator）模式定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</li>
<li><strong>优点</strong><br>1.降低了对象之间的耦合性，使得对象易于独立地被复用。<br>2.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
<li><strong>缺点</strong><br>1.当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
<li><strong>应用场景</strong><br>1.当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。<br>2.当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhongjiezheYY.gif" alt="中介者模式实际应用UML" loading="lazy"></center><br>
<br><center>韶关房地产交流平台的结构图</center></li>
</ul>
<p><a name="责任链模式"></a></p>
<h3 id="22-责任链模式">22、<a href="http://c.biancheng.net/view/1383.html">责任链模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zerenlian.gif" alt="责任链模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：责任链（Chain of Responsibility）模式为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</li>
<li><strong>优点</strong><br>1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
<li><strong>缺点</strong><br>1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<br>2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。<br>3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
<li><strong>应用场景</strong><br>1.多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。<br>2.可动态指定一组对象处理请求，或添加新的处理者。<br>3.需要在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zerenlianYY.gif" alt="责任链模式实际应用" loading="lazy"></center><br>
<br><center>请假条审批模块的结构图</center></li>
</ul>
<p><a name="访问者模式"></a></p>
<h3 id="23-访问者模式">23、<a href="http://c.biancheng.net/view/1397.html">访问者模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/fangwenzhe.jpg" alt="访问者模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：访问者（Visitor）模式将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</li>
<li><strong>优点</strong><br>1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。<br>2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。<br>3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。<br>4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
<li><strong>缺点</strong><br>1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。<br>2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。<br>3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
<li><strong>应用场景</strong><br>1.对象结构相对稳定，但其操作算法经常变化的程序。<br>2.对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。<br>3.对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/fangwenzheYY.png" alt="访问者模式实际应用UML" loading="lazy"></center><br>
<br><center>艺术公司与造币公司的结构图</center></li>
</ul>
<p><a name="状态模式"></a></p>
<h3 id="24-状态模式">24、<a href="http://c.biancheng.net/view/1388.html">状态模式</a></h3>
<ul>
<li><strong>UML图</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangtai.gif" alt="状态模式结构图" loading="lazy"></center></li>
<li><strong>定义</strong>：状态（State）模式对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</li>
<li><strong>优点</strong><br>1.结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。<br>2.将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。<br>3.状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
<li><strong>缺点</strong><br>1.状态模式的使用必然会增加系统的类与对象的个数。<br>2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。<br>3.状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li>
<li><strong>应用场景</strong><br>1.当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。<br>2.一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
<li><strong>实际应用UML</strong><br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/zhuangtaiYY.png" alt="状态模式实际应用UML" loading="lazy"></center><br>
<br><center>学生成绩的状态转换程序的结构图</center></li>
</ul>
<p><a name="JAVA并发编程"></a></p>
<h2 id="java并发编程">JAVA并发编程</h2>
<p><a name="volatile"></a></p>
<h3 id="1-volatile">1、volatile</h3>
<ul>
<li>强制将变量修改后的值从工作内存写入主内存，保证线程变量的可见性及有序性。但是有序又涉及到了复杂的指令重排、内存屏障等，未做了解。<br></li>
<li>volatile并不能保证原子性，原子性问题得依赖synchronized、ReentrantLock等加锁机制来解决。</li>
<li>另外，多个线程同时修改同一个变量，可能导致线程安全问题，数据混乱问题(修改错乱)，这也是不能保证原子性的原因。</li>
<li><strong>问题一(总线风暴)</strong>：每个处理器通过嗅探在总线上传播的数据来验证自己缓存的数据是否过期。而<strong>嗅探的缺点</strong>是由于Volatile的MESI缓存一直性协议，需要不断的从主内存嗅探和CAS循环，无效的交互会达到总线的峰值。</li>
<li><strong>问题二(禁止指令重排)</strong>：涉及很多计算机底层，告辞</li>
<li><strong>指令重排(一般指令重排分为三种)</strong>：<br>&lt;a&gt;编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;<br>&lt;b&gt;指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;<br>&lt;c&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li>
</ul>
<p><a name="JAVA8如何优化CAS性能"></a></p>
<h3 id="2-java8如何优化cas性能">2、JAVA8如何优化CAS性能</h3>
<ul>
<li>全称compare and set——<strong>先比较再设置</strong></li>
<li>在并发操作变量时，cas提供了一系列的Atomic原子类来提供操作。</li>
<li><strong>优化的点</strong>：可以代替synchronized变量的高并发修改赋值，也就是不需要重复的等待锁-&gt;加锁-&gt;修改赋值-&gt;释放锁的类似串行化的步骤。</li>
<li><strong>原子性</strong>：操作完整执行完并且不会被别人打断。</li>
<li><strong>底层原理</strong>：首先获取变量值，询问比较是否发生变化，如果变化则重新获取值，如果未变化则赋值，最后完成这一CAS原子操作。由于加了先比较后赋值的处理机制，可以去掉加锁的机制，所以所有线程可以同步进行这一CAS原子操作。</li>
<li><strong>缺点</strong>：由于获取值的过程中会有大量的获取动作(会有大量的比较失败的情况)，导致高并发的时候线程空循环，自旋，性能效率不是很理想。</li>
<li><strong>针对缺点的优化</strong>：JAVA8中推出了新的类-LongAdder，再采取分段CAS以及自动分段迁移的方式大幅提升多线程高并发的性能问题。</li>
<li><strong>分段CAS机制</strong>：<font color="red">找了很多别人写的文章，依然只看到同样的针对base值的累加时，使用cell数组将线程分组，并且每组各个只针对对应组的cell一个元素做累加，并且最后将所有cell汇总到base减少线程自旋等待。这里就有个问题，假如在使用CAS的时候并不是涉及自增或者自减的时候，是否能用，或者在能用的情况下是如何实现的？</font></li>
</ul>
<p><a name="各种锁的应用场景"></a></p>
<h3 id="3-各种锁的应用场景">3、各种锁的应用场景</h3>
<ul>
<li><strong>互斥锁</strong>：互斥锁加锁失败后会释放cpu给其他线程。<br>
<br>互斥锁是一种独占锁，在A线程独占锁之后B线程加锁失败的情况下，并且B释放掉cpu后，就会阻塞后续的代码。这种锁是由<strong>操作系统底层内核实现</strong>的，当加锁失败后线程被设置为睡眠，后续由系统来在合适的时机唤醒线程，并继续加锁执行。<br>
<br><strong>开销成本</strong>：有两次的上下文切换的成本。而这上下文切换的时间由于操作系统虚拟内存的原因会比较耗时，在代码执行时间短的情况下上下文切换的时间会比代码执行的时间更久，拖累线程速度。<br>
<br><strong>线程的上下文切换的是什么？</strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>
<li><strong>自旋锁</strong>：加锁失败后线程会忙等待，直到拿到锁。<br>
<br>自旋锁是通过cpu提供的<strong>CAS函数(Compare and Swap)</strong>在[用户态]完成加锁和解锁的操作，不会主动产生上下文切换,比互斥锁开销会小。<br>一般加锁分为2个步骤：<br>1.查看锁的状态，如果是空闲的则执行第二步;<br>2.将锁设置为线程持有;<br>CAS函数将这2个步骤合并为一条硬件级指令，形成原子指令，这样就保证了要么执行完，要么完全没执行。<br>
<br><strong>开销成本</strong>：在其他线程等待锁的情况下，会利用cpu周期不断自旋，如果在锁代码执行周期较长的情况下，会较大消耗cpu资源。<br>
<br><h3> CFC小结： </h3>    以上2个锁构成了最基本的锁的方式。简单的可以从需要加锁的代码执行时长来判断使用哪种锁。</li>
<li><strong>读写锁</strong>：分为公平性与非公平性，或读写的优先级锁。</li>
<li><strong>公平锁</strong>即按照队列将读锁与写锁顺序执行。</li>
<li><strong>非公平锁</strong>会造成锁之间的竞争，不管是读锁优先还是写锁优先都会造成另一个锁饥饿甚至饿死的情况。</li>
<li><strong>悲观锁</strong>：以上即悲观。</li>
<li><strong>乐观锁</strong>：其实是没有锁的状态也称无锁编程。主要是在先修改后比较原先资源是否被修改过，如果被修改过则放弃修改重新读取修改。重试的成本高，所以只适用于<strong>冲突少</strong>的场景，类似于git，svn。</li>
<li><strong>Synchronized的实现</strong>：</li>
</ul>
<p><a name="JVM底层"></a></p>
<h2 id="jvm底层">JVM底层</h2>
<p><a name="垃圾回收"></a></p>
<h3 id="垃圾回收">垃圾回收</h3>
<p><strong>GC 的几种主要的收集方法</strong>：标记清除、标记整理、复制算法</p>
<ul>
<li><strong>垃圾的识别</strong>：<br>1. 引用计数器(无法解决循环引用问题)——当A实例引用B实例，B实例引用A实例时，对象没有其他引用后依然无法被识别并回收。<br>2.可达性算法：以GC ROOT为根不断寻找下一个节点，任何不在引用链上的都会被标记为垃圾。但是在标记前会执行一次(有且只有一次，如果已执行过则不执行)finalize方法，然后重新判断是否在引用链上，如果仍然不在才能被标记。<br>3.GC ROOT：<br>&lt;a&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>&lt;b&gt;方法区中类静态属性引用的对象。<br>&lt;c&gt;方法区中常量引用的对象。<br>&lt;d&gt;本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</li>
<li><strong>标记清除算法</strong>：根据可达性算法标记出相应的可回收对象，直接回收。</li>
<li><strong>复制算法</strong>：首先要把堆分成2块区域A跟B，将清除后的内存空间A复制到B空间中并紧密排列，清理堆A中所有对象，释放A空间。</li>
<li><strong>标记整理算法</strong>：在标记清除算法的基础上将所有存活的对象都往一个方向移动，并清理掉另外一边所有区域。频繁移动存货对象导致效率低下。</li>
<li><strong>分代收集算法</strong>：整合了以上所有算法，综合了优点，并最大程度避免他们的缺点。根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),三者的比例为 8: 1 : 1，这样就可以根据新老生代的特点选择最合适的垃圾回收算法，我们把新生代发生的 GC 称为 Young GC（也叫 Minor GC）,老年代发生的 GC 称为 Old GC（也称为 Full GC）。<br>
需要再次梳理分代收集算法</li>
</ul>
<p><a name="AQS(AbstractQueuedSynchronizer)抽象队列同步器"></a></p>
<h3 id="aqsabstractqueuedsynchronizer抽象队列同步器">AQS(AbstractQueuedSynchronizer)抽象队列同步器</h3>
<p>ReentrantLock可重入锁与ReentrantReadWriteLock可可重入读写锁底层都是基于AQS实现的。</p>
<p><a name="ArrayList"></a></p>
<h3 id="arraylist">ArrayList</h3>
<p><strong>ArrayList与Vector的区别</strong>：<br>
Vector所有方法都是同步的，在不需要多线程保证线程安全的情况下可以使用ArrayList减少不必要的大量同步操作。<br>
<br><strong>ArrayList的扩容机制</strong>：<br>
<br>自动扩容源码</p>
<pre><code class="language-java">    // 扩容一个
    private Object[] grow() {
	    return grow(size + 1);
    }
    // 保证扩容到期望容量minCapacity及以上
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData,newCapacity(minCapacity));
    }
    // 根据期望容量minCapacity计算实际需要扩容的容量
    private int newCapacity(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length; // 得到旧容量
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 设置新容量为旧容量的1.5倍
    if (newCapacity - minCapacity &lt;= 0) { // 如果新容量仍然小于期望容量
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // 如果是使用的默认容量
            return Math.max(DEFAULT_CAPACITY, minCapacity); // 取默认容量和期望容量较大值返回
        if (minCapacity &lt; 0) // overflow // 检查期望容量是否越界（int 的范围）
            throw new OutOfMemoryError();
        return minCapacity; // 返回期望容量
    }
// 如果新容量大于期望容量，判断一下新容量是否越界
    return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)? newCapacity : hugeCapacity(minCapacity);
}
</code></pre>
<p>手动扩容源码</p>
<pre><code class="language-java"> public void ensureCapacity(int minCapacity) {
    if (minCapacity &gt; elementData.length
    &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
    &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
        modCount++;
        grow(minCapacity);
    }
}
</code></pre>
<p><strong>调用ADD方法执行流程</strong><br>
<br>当使用无参构造的时候，在第一次调用add方法之后的执行流程<br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/arraylistgrowflow.png" alt="调用ADD方法执行流程" loading="lazy"></center><br>
<br>这是第一次调用add方法的过程，当扩容值capacity为10之后</p>
<ul>
<li>继续添加第2个元素（先注意调用ensureCapacityInternal方法传递的参数为size+1=1+1=2）</li>
<li>ensureExplicitCapacity方法中minCapacity为刚刚传递的2，所以第二个if判断（2-10=-8）不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 grow 方法。数组容量为10，add方法中 return true,size增为1。</li>
<li>假设又添加3、4......10个元素(其中过程类似，但是不会执行grow扩容方法)</li>
<li>当add第11个元素时候，会进入grow方法时，计算newCapacity为15，比minCapacity（为10+1=11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。<br>
<strong>关于对指定位置插入数据的方法add(int index,E element)</strong>如非必要不要使用。在指定位置插入时，假设该位置合法，首先会检测是否有足够的数组空间，然后将index及其之后的数据都向后移动一位，最后将新的元素插入到index的位置。<br>其中<strong>复杂程度</strong>为O(N)，频繁移动导致的复杂程度将更高，影响效率。</li>
</ul>
<p><a name="HashMap底层实现"></a></p>
<h3 id="hashmap底层实现">HashMap底层实现</h3>
<p><strong>java1.8之前</strong>：数组加链表组成的链表散列，通过key的扰动函数处理后得到hash值，通过(n-1)&amp;hash判断当前元素存放位置，如果当前位置存在元素，相当于已经有了这个key，如果key与hash都相同，直接覆盖当前位置的值。如果不相同就通过拉链法解决冲突。<br>
<br><strong><a href="https://zerononet.github.io/post/hashmap-rao-dong-han-shu/">扰动函数</a></strong><br>
<br><strong>存储结构</strong>：数组+链表+红黑树(1.8+)，链表长度大于8时转成链表转成红黑树。<br>
<br><strong>链地址法</strong>：数组加链表的结合。每个数组上都有个链表结构，执行key的hashcode()方法得到hash值，再通过Hash算法的后两步运算(高位运算和取模运算)定位该键值对的存储位置，如果2个key定位到相同位置说明发生hash碰撞，碰撞概率取决与桶(node)的大小与Hash算法。所以为了减少碰撞会有扩容机制。<br>
<br><strong>初始化</strong>：哈希桶数组(node[] table)初始大小为16。负载因子默认为0.75。<br>
<br><strong>扩容机制</strong>：在默认情况下每次put操作都会比较当前容量与存放数量(size)，如果size大于16*0.75=12时，会进行扩容操作。<strong>扩容时会重新计算每个元素在数组中的位置然后再进行存储，十分消耗性能</strong>。<br>
<br><strong>线程不安全</strong>：resize()的时候多线程情况下头插法会使得链路出现环形链表甚至数组下标超出。而1.8后使用的是尾插去优化仍然带来了其他问题，比如尾插时计算相同的存放位置，如果在A线程put完成后，B线程又正好计算在Aput前计算完成存放位置，就会把A线程put的值给覆盖，而不是判断是否碰撞，造成线程不安全。</p>
<p><a name="ConcurrentHashMap底层实现"></a></p>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p><a href="https://my.oschina.net/pingpangkuangmo/blog/817973#h2_12">以下总结转载自本链接</a><br>
<br>1.8的ConcurrentHashMap摒弃了1.7的segment设计，而是在1.8HashMap的基础上实现了线程安全的版本，即也是采用数组+链表+红黑树的形式。数组可以扩容，链表可以转化为红黑树。</p>
<p><a name="JAVA代理"></a></p>
<h3 id="java代理">JAVA代理</h3>
<p><a name="静态代理"></a></p>
<h4 id="静态代理">静态代理</h4>
<p>需要继承对应代理的相同接口来实现静态代理，当存在多个目标的情况下代理的数量就会增多。虽然静态代理生成的是.class字节码文件，性能好效率高，但是过多的目标下导致代码繁杂不易维护。</p>
<p><a name="动态代理"></a></p>
<h4 id="动态代理">动态代理</h4>
<p>必须实现InvocationHandler接口，通过JAVA反射的方式动态的在去生成代理，虽然可以灵活使用，但是比较消耗性能。</p>
<p><a name="CGLIB代理"></a></p>
<h4 id="cglib代理">CGLIB代理</h4>
<p>CGLIB代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但是会继承目标对象，需要重写方法。所以目标对象不能是final类。</p>
<p><a name="Spring框架"></a></p>
<h2 id="spring框架">Spring框架</h2>
<p><a name="SpringBoot"></a></p>
<h3 id="什么是spring-boot-stater">什么是Spring Boot Stater</h3>
<blockquote>
<p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。<br>而Spring Boot Starter就是其中的一个启动器，节省了Spring的繁琐配置，高效搭建环境并进行开发。</p>
</blockquote>
<p><a name="SpringBoot优点"></a></p>
<h3 id="spring-boot的优点">Spring Boot的优点</h3>
<ul>
<li>减少开发，测试时间和努力。</li>
<li>使用JavaConfig有助于避免使用XML。</li>
<li>避免大量的Maven导入和各种版本冲突。</li>
<li>提供意见发展方法。</li>
<li>通过提供默认值快速开始开发。</li>
<li>没有单独的Web服务器需要。这意味着你不再需要启动Tomcat，Glassfish或其他任何东西。</li>
<li>需要更少的配置 因为没有web.xml文件。只需添加用@ Configuration注释的类，然后添加用@Bean注释的方法，Spring将自动加载对象并像以前一样对其进行管理。您甚至可以将@Autowired添加到bean方法中，以使Spring自动装入需要的依赖关系中。基于环境的配置 使用这些属性，您可以将您正在使用的环境传递到应用程序：-Dspring.profiles.active = {enviornment}。在加载主应用程序属性文件后，Spring将在（application{environment} .properties）中加载后续的应用程序属性文件。</li>
</ul>
<p><a name="SpringBoot的核心配置文件"></a></p>
<h3 id="spring-boot的核心配置文件">Spring Boot的核心配置文件</h3>
<ul>
<li>Spring Boot 的核心配置文件是 application 和 bootstrap 配置文件。</li>
<li>application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。</li>
<li>bootstrap 配置文件有以下几个应用场景。<br>
<br>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息； 一些固定的不能被覆盖的属性；一些加密/解密的场景</li>
</ul>
<h4 id="配置文件的格式">配置文件的格式</h4>
<p>v.properties 和 .yml，它们的区别主要是书写格式不同。</p>
<p><a name="SpringBoot的核心注解"></a></p>
<h3 id="spring-boot-的核心注解是哪个它主要由哪几个注解组成的">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3>
<blockquote>
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解 主要组合包含了以下 3 个注解：<br>
<br>1.@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。<br>
<br>2.@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。<br>
<br>3.@ComponentScan：Spring组件扫描。</p>
</blockquote>
<p><a name="SpringBoot的运行方式"></a></p>
<h3 id="spring-boot的运行方式">Spring Boot的运行方式</h3>
<ol>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven/ Gradle 插件运行</li>
<li>直接执行 main 方法运行(Spring Boot内置了Tomcat/Jetty等容器)</li>
</ol>
<p><a name="SpringBoot实现分页和排序"></a></p>
<h3 id="spring-boot实现分页和排序">Spring Boot实现分页和排序</h3>
<p>使用Spring Data-JPA可以实现将可分页的org.springframework.data.domain.Pageable传递给存储库方法。</p>
<p><a name="SpringBoot应用程序的安全性"></a></p>
<h3 id="spring-boot应用程序的安全性">Spring Boot应用程序的安全性</h3>
<p>为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。</p>
<p><a name="SpringBoot中的监视器"></a></p>
<h3 id="spring-boot中的监视器">Spring Boot中的监视器</h3>
<p>Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p>
<p><a name="SpringBoot实现Swagger"></a></p>
<h3 id="spring-boot实现swagger">Spring Boot实现Swagger</h3>
<p>Swagger广泛用于可视化API，使用Swagger UI为前端开发人员提供在线沙箱。Swagger是用于生成RESTful Web服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过Swagger正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p>
<p><a name="SpringBoot实现异常处理"></a></p>
<h3 id="spring-boot实现异常处理">Spring Boot实现异常处理</h3>
<p>Spring提供了一种使用ControllerAdvice处理异常的非常有用的方法。 我们通过实现一个ControlerAdvice类，来处理控制器类抛出的所有异常。</p>
<p><a name="RequestMapping和GetMapping的不同之处"></a></p>
<h3 id="requestmapping-和-getmapping-的不同之处">RequestMapping 和 GetMapping 的不同之处</h3>
<p>RequestMapping 具有类属性的，可以进行 GET,POST,PUT 或者其它的注释中具有的请求方法。<br>
GetMapping 是 GET 请求方法中的一个特例。它只是 ResquestMapping 的一个延伸，目的是为了提高清晰度。</p>
<p><a name="Spring-IOC"></a></p>
<h3 id="spring-ioc">Spring IOC</h3>
<ul>
<li><strong>IoC - Inversion of Control, 控制反转</strong>：控制反转就是把创建和管理 bean 的过程转移给了第三方。而这个第三方，就是 Spring IoC Container，对于 IoC 来说，最重要的就是容器。</li>
<li><strong>IOC其实是一个编程思想，具体实现是DI 依赖注入</strong></li>
<li><strong>为什么需要使用IOC</strong>：解耦。</li>
<li><strong>使用</strong>：通过xml配置bean属性，然后 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;service.xml&quot;);通过context对象取得xml中配置的bean，并会自动将配置的属性对应值赋上。</li>
<li><strong>对象在容器中是否单例</strong>：是</li>
<li><strong>容器的对象是什么时候创建的</strong>：每次启动容器的时候就已经创建好其中的对象了。</li>
</ul>
<p><a name="Spring-AOP"></a></p>
<h3 id="spring-aop">Spring AOP</h3>
<p>众所周知Aspect Oriented Program 面向切面编程，将一整块需要实现的代码切分开来，区分核心业务，业务周边的系统功能。分开定义并实现，最后通过springAOP模块来将这些功能编织在一起形成一个完整的实现功能。<br>
<br>个人认为一定程度上提高了代码复用性，增加了可读性和可维护性。<br>
<br><strong>术语</strong></p>
<ul>
<li>切入点（Pointcut）<br>
在哪些类，哪些方法上切入（where）</li>
<li>通知（Advice）<br>
在方法执行的什么实际（when:方法前/方法后/方法前后）做什么（what:增强的功能）</li>
<li>切面（Aspect）<br>
切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！</li>
<li>织入（Weaving）<br>
把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li>
</ul>
<p><strong><font color="red">CFC总结：</font></strong>个人觉得在整体的AOP配置过程中，主要需要注意2个点：<br>1.切点的定义，需要同时规范同类型的织入类的类命名，再使用尽可能准确的正则表达式对切点作出限制。<br>2.连接点的选择，具体是以类为连接点还是某个方法为连接点，需要根据实际情况针对某个切面作出规范。<br>以上都是针对协同开发总结的注意点。<br>
<br><strong>关键的点</strong>：Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理。如果需要为一个类实现代理, 那么可以使用 CGLIB 代理。 当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类。</p>
<p><a name="Redis"></a></p>
<h2 id="redis">Redis</h2>
<p><a name="五大数据结构"></a></p>
<h3 id="五大数据结构">五大数据结构</h3>
<ul>
<li>String</li>
<li>Hash</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
</ul>
<p><a name="缓存过期"></a></p>
<h3 id="缓存过期">缓存过期</h3>
<ul>
<li>过于集中的缓存过期时间会导致短暂卡顿现象——<strong>缓存雪崩</strong>。<br>解决：将失效时间加上随机值，分散过期。</li>
</ul>
<p><a name="持久化"></a></p>
<h3 id="持久化">持久化</h3>
<ul>
<li><strong>RDB做镜像全量持久化，AOF做增量持久化</strong>。全量需要时间长，容易丢失大量数据，需要AOF配合。恢复的时候也是一样，先全量恢复，然后增量恢复到重启前状态。<br>突然断电的情况数据丢失取决于AOF日志于sync配置，但是往往每条指令都sync一下到磁盘是不现实的，一般使用定时，一秒一次，最多丢失一秒的数据。</li>
<li><strong>RDB原理</strong>：fork AND cow——fork值redis通过创建子进程进行rdb操作；cow指的是copy on write，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开。</li>
</ul>
<p><a name="JAVA8如何优化CAS性能"></a></p>
<h3 id="同步机制">同步机制</h3>
<ul>
<li><strong>可以主从同步或从从同步</strong>。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</li>
</ul>
<p><a name="集群与高可用"></a></p>
<h3 id="集群与高可用">集群与高可用</h3>
<ul>
<li><strong>Redis Sentinal</strong> 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</li>
<li><strong>Redis Cluster</strong> 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</li>
</ul>
<p><a name="分布式锁"></a></p>
<h3 id="分布式锁">分布式锁</h3>
<ul>
<li>先拿setnx来争抢锁，抢到后使用<strong>expire</strong>来设置过期时间。</li>
<li><strong>存在问题(同存在与Zookeeper、Mysql中)</strong>：当JAVA中执行的GC为STW stop the world的时候，可能会导致锁获得锁的线程A停顿等待GC完成，此时获取到的分布式锁过期，超时释放。其他线程B获取继续获取到锁，开始写数据。而A线程GC完成，继续执行写数据的操作。导致分布式锁不安全(相当于是2个线程同时获取到锁)。</li>
<li><strong>不能执行过长时间的任务</strong>：加锁和释放锁之间的逻辑执行得太长，以至于超出了锁的超时限制，导致代码无法严格的串行执行。锁被提前释放，提前持有。<br>解决：稍微安全一点的方案是 将锁的 value 值设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key，这是为了 确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期了而被服务器自动释放的。但是匹配 value 和删除 key 在 Redis 中并不是一个原子性的操作，也没有类似保证原子性的指令，所以可能需要使用像 Lua 这样的脚本来处理了，因为 Lua 脚本可以 保证多个指令的原子性执行。</li>
</ul>
<p><a name="跳跃表"></a></p>
<h3 id="跳跃表">跳跃表</h3>
<ul>
<li><strong>多层链表</strong>：从最上层的链表(节点少)去查找并比对，一层一层往下定位直到找到位置。<br>优势：可以跳过很多节点，提高查找效率。</li>
</ul>
<p><a name="数据结构与算法"></a></p>
<h2 id="数据结构与算法">数据结构与算法</h2>
<p><a name="红黑树(自平衡二叉查找树)"></a></p>
<h3 id="红黑树自平衡二叉查找树">红黑树(自平衡二叉查找树)</h3>
<ul>
<li><strong>二叉查找树（BST）特性</strong>：<br>1.左子树上所有结点的值均小于或等于它的根结点的值。<br>2.右子树上所有结点的值均大于或等于它的根结点的值。<br>3.左、右子树也分别为二叉排序树。</li>
<li><strong>只读操作相同</strong></li>
<li><strong>红黑树性质：</strong><br>1.节点是红色或黑色。<br>2.根是黑色。<br>3.所有叶子都是黑色（叶子是NIL节点）。<br>4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
<li><strong>操作：1.变色；2.左旋转；3.右旋转；</strong></li>
<li><strong>插入</strong></li>
<li><strong>删除</strong></li>
</ul>
<!--
# <center>升级之路</center> #
## 以实际应用结合讲设计模式 ##
## 1、数据库的锁 ##
#### 行锁（共享锁和排他锁），表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁等 ####
## 2、数据结构 ##
#### 红黑树，B树，B+树，二叉树，HashMap ####
## 3、Redis ##
#### 分布式的哨兵到3.0之后的去中心化集群（奇数节点）、高并发、单线程、在线扩容、持久化方式(断电保护) ####
## 4、HashMap ##
#### 单向链表的特性导致会有Entry链、PUT&GET原理，初始容量(rehash扩容问题)，线程不安全(resize死循环)，与HashTable的区别 ####
## 5、线程池 ##
#### 四种线程池，JDK拒绝策略 ####
## 6、JVM ##
#### Object的内存布局，方法区卸载Class的条件，可以作为GC ROOT的对象包括，JVM运行内存模型，Netty的ByteBuffer的引用计数器机制，对象是否存活的判断，JAVA对象的初始化，类加载的双亲委派模型，动态代理模式(cglib,jdk动态代理)####
## 7、Zookeeper ##
#### 常见的应用场景，分布式数据的一致性算法，ZK的启动及Leader选举，数据同步，ZK集群最少需要2N+1，Zookeeper与Eureka的区别 ####
## 8、消息队列 ##
#### 消费者宕机保证消息不丢失，集群宕机保证消息不丢失 ####
## 9、Spring源码 ##
#### springmvc如何解决循环依赖的问题，spring事务的传播行为和隔离级别，Spring事务的五种隔离级别，SpringAOP ####
## 10、设计模式 ##
#### 单例模式(7种)，策略模式 ####
## 11、JDK源码 ##
#### ThreadLocal的实现原理，AQS实现公平锁和非公平锁，RPC的序列方式 ####
## 12、服务熔断与降级概念 ##
#### 服务熔断，服务降级 ####
## 13、索引 ##
#### 正排索引，倒排索引 ####

-->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA的三种代理]]></title>
        <id>https://zerononet.github.io/post/dai-bu-chong-dong-tai-dai-li/</id>
        <link href="https://zerononet.github.io/post/dai-bu-chong-dong-tai-dai-li/">
        </link>
        <updated>2020-06-17T12:53:39.000Z</updated>
        <content type="html"><![CDATA[<p>不论任何的代理，其实都是使用了代理模式的设计模式。</p>
<h1 id="center静态代理center"><center>静态代理</center></h1>
<p>需要跟代理的目标实现同一个接口，然后在代理类中增加方法接收传入的对应初始化接口的实现类target，然后实现接口方法中使用target去调用接口方法就可以做到代理。<br>
<br><strong>代码实现结构</strong><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/20201121110516.png" alt="静态代理UML类图" loading="lazy"></center><br>
<br><center>UML图</center><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/20201121110356.png" alt="接口类" loading="lazy"></center><br>
<br><center>图：接口类</center><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/20201121104933.png" alt="实现类" loading="lazy"></center><br>
<br><center>图：实现类</center><br>
<br><center><img src="https://raw.githubusercontent.com/ZERONONET/photos/master/Gridea/20201121104716.png" alt="代理类" loading="lazy"></center><br>
<br><center>图：代理类</center><br>
<br>可以明显的看出来，当接口多了的情况下(接口隔离原则)所需要的代理实现类就多了，不方便维护。而其中的好处就是这个代理不通过反射动态生成，在编译的时候就可以生成字节码.class文件，运行高效，可以作为优化使用。</p>
<h1 id="centerjdk动态代理center"><center>JDK动态代理</center></h1>
]]></content>
    </entry>
</feed>